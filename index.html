<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#232526">
  <meta name="format-detection" content="telephone=no">
  <title>Lacrosse Ball Rep Tracker</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>

  <style>
    :root {
      --primary: #4CAF50;
      --primary-dark: #388E3C;
      --primary-light: #C8E6C9;
      --accent: #2196F3;
      --accent-dark: #1976D2;
      --danger: #f44336;
      --danger-dark: #d32f2f;
      --dark: #232526;
      --dark-lighter: #414345;
      --light: #f0f0f0;
      --gray: #ccc;
      --transition: all 0.3s ease;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(to right, var(--dark), var(--dark-lighter));
      color: var(--light);
      font-family: 'Poppins', sans-serif;
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      text-align: center;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .container {
      width: 100%;
      max-width: 1200px;
      padding: 1rem;
      margin: 0 auto;
    }

    h1 {
      margin-bottom: 0.5rem;
      font-size: 2.5rem;
      color: var(--primary);
      animation: fadeInDown 1s ease-out;
    }

    p {
      margin-bottom: 1.5rem;
      font-size: 1.1rem;
      color: var(--gray);
    }

    /* Rep Counter Styles */
    #reps-container {
      font-size: 2.5rem;
      margin-bottom: 1.5rem;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      background: rgba(44, 44, 44, 0.7);
      padding: 1.5rem;
      border-radius: 15px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    #reps {
      font-size: 3rem;
      font-weight: 600;
      color: var(--primary);
    }

    #timer, #rpm {
      font-size: 1.5rem;
      color: var(--light);
    }

    /* Goal Container Styles */
    #goal-container {
      width: 100%;
      max-width: 500px;
      margin: 1rem auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      background: rgba(44, 44, 44, 0.7);
      padding: 1.5rem;
      border-radius: 15px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    #goal-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      gap: 15px;
    }

    .goal-input-wrapper {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #goal-input {
      width: 80px;
      text-align: center;
      font-size: 1.2rem;
      background: #333;
      color: var(--light);
      border: 1px solid #555;
      border-radius: 8px;
      padding: 8px;
    }

    .goal-adjust-button {
      width: 36px;
      height: 36px;
      font-size: 1.5rem;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: var(--transition);
    }

    .goal-adjust-button:hover {
      background: var(--primary-dark);
    }

    .goal-adjust-button:active {
      transform: scale(0.95);
    }

    /* Progress Bar Styles */
    #progress-bar-container {
      width: 100%;
      background-color: #555;
      border-radius: 10px;
      margin-top: 1rem;
      overflow: hidden;
    }

    #progress-bar {
      width: 0%;
      height: 20px;
      background-color: var(--primary);
      border-radius: 10px;
      transition: width 0.5s ease-in-out;
    }

    /* Button Styles */
    .control-button, #reset-button, #view-toggle, #focus-mode-button {
      font-size: 1rem;
      padding: 0.8rem 1.5rem;
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      transition: var(--transition);
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 500;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      margin: 0.5rem;
    }

    .control-button {
      background: var(--accent);
    }

    .control-button:hover {
      background: var(--accent-dark);
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
    }

    .control-button:active {
      transform: translateY(-1px);
    }

    #reset-button {
      background: var(--danger);
    }

    #reset-button:hover {
      background: var(--danger-dark);
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
    }

    #controls-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 1rem;
      margin-top: 1.5rem;
    }

    /* Video and Canvas Styles */
    video {
      display: none;
    }

    canvas {
      max-width: 100%;
      width: 100%;
      height: auto;
      border-radius: 15px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      display: block;
      margin: 1rem auto;
      background-color: #000;
    }

    /* Menu Icon Styles */
    #menu-icon {
      position: fixed;
      top: 20px;
      right: 20px;
      cursor: pointer;
      z-index: 1001;
      width: 40px;
      height: 40px;
      background: rgba(44, 44, 44, 0.7);
      border-radius: 50%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 5px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    #menu-icon div {
      width: 25px;
      height: 3px;
      background-color: white;
      border-radius: 3px;
      transition: var(--transition);
    }

    #menu-icon.open div:nth-child(1) {
      transform: translateY(8px) rotate(45deg);
    }

    #menu-icon.open div:nth-child(2) {
      opacity: 0;
    }

    #menu-icon.open div:nth-child(3) {
      transform: translateY(-8px) rotate(-45deg);
    }

    /* Navigation Drawer Styles */
    #nav-drawer {
      position: fixed;
      top: 0;
      right: -300px;
      width: 280px;
      height: 100%;
      background-color: rgba(44, 44, 44, 0.95);
      padding-top: 70px;
      transition: var(--transition);
      z-index: 1000;
      display: flex;
      flex-direction: column;
      align-items: center;
      box-shadow: -5px 0 15px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    #nav-drawer.open {
      right: 0;
    }

    #nav-drawer .control-button {
      width: 80%;
      margin-bottom: 15px;
      text-align: center;
    }

    /* Toggle Switch Styles */
    .toggle-switch-container {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 80%;
      margin: 15px 0;
      padding: 10px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
    }

    .switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 34px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: var(--transition);
      border-radius: 34px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 26px;
      width: 26px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: var(--transition);
      border-radius: 50%;
    }

    input:checked + .slider {
      background-color: var(--primary);
    }

    input:focus + .slider {
      box-shadow: 0 0 1px var(--primary);
    }

    input:checked + .slider:before {
      transform: translateX(26px);
    }

    /* Modal Styles */
    .modal {
      position: fixed;
      z-index: 1100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: var(--transition);
    }

    .modal.show {
      opacity: 1;
      visibility: visible;
    }

    .modal-content {
      background: #333;
      padding: 25px;
      border: none;
      width: 90%;
      max-width: 400px;
      border-radius: 15px;
      text-align: center;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      transform: scale(0.9);
      transition: var(--transition);
    }

    .modal.show .modal-content {
      transform: scale(1);
    }

    .close-button {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      transition: var(--transition);
    }

    .close-button:hover,
    .close-button:focus {
      color: white;
      text-decoration: none;
    }

    #login-modal input {
      width: 100%;
      padding: 12px;
      margin-bottom: 15px;
      border-radius: 8px;
      border: 1px solid #555;
      background: #444;
      color: var(--light);
      font-family: inherit;
    }

    #leaderboard-list, #session-history-list {
      list-style: none;
      padding: 0;
      margin-top: 20px;
      max-height: 300px;
      overflow-y: auto;
    }

    #leaderboard-list li, #session-history-list li {
      background: #444;
      margin-bottom: 10px;
      padding: 15px;
      border-radius: 8px;
      transition: var(--transition);
      text-align: left;
    }

    #leaderboard-list li:hover, #session-history-list li:hover {
      background-color: #555;
      transform: scale(1.02);
    }

    /* Notification Styles */
    #notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: var(--primary);
      color: white;
      padding: 15px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      transform: translateX(150%);
      transition: transform 0.3s ease;
    }

    #notification.show {
      transform: translateX(0);
    }

    /* Camera Status Styles */
    #camera-status {
      margin: 1rem auto;
      padding: 1rem;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 8px;
      max-width: 400px;
    }

    /* Focus View Styles */
    .focus-view h1,
    .focus-view p,
    .focus-view #menu-icon,
    .focus-view #save-button,
    .focus-view #reset-button,
    .focus-view canvas,
    .focus-view #nav-drawer,
    .focus-view #focus-mode-button,
    .focus-view #goal-container {
      display: none;
    }

    .focus-view #reps-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: #000;
      z-index: 2000;
      border-radius: 0;
    }

    .focus-view #reps {
      font-size: 25vw;
      color: var(--primary);
    }

    .focus-view #timer, .focus-view #rpm {
      font-size: 5vw;
    }

    .focus-view #exit-focus-mode {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 2001;
      display: block;
    }

    /* Loader Styles */
    #loader {
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      z-index: 9999;
      background: var(--dark);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      transition: opacity 0.5s ease, visibility 0.5s ease;
    }

    .loader-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 20px;
    }

    .loader-spinner {
      width: 60px;
      height: 60px;
      border: 5px solid rgba(76, 175, 80, 0.3);
      border-radius: 50%;
      border-top-color: var(--primary);
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loader-text {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--primary);
    }

    .loader-progress {
      width: 250px;
      height: 10px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 5px;
      overflow: hidden;
      margin-top: 10px;
    }

    #loader-progress {
      height: 100%;
      width: 0%;
      background: var(--primary);
      transition: width 0.3s ease;
    }

    #loader-percentage {
      margin-top: 5px;
      font-size: 1rem;
      color: var(--light);
    }

    .loader-message {
      font-size: 0.9rem;
      color: var(--gray);
      text-align: center;
      max-width: 80%;
    }

    /* Animations */
    @keyframes fadeInDown {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Responsive Styles */
    @media (max-width: 768px) {
      h1 {
        font-size: 2rem;
      }

      p {
        font-size: 1rem;
      }

      #reps-container {
        font-size: 2rem;
        padding: 1rem;
      }

      #reps {
        font-size: 2.5rem;
      }

      #timer, #rpm {
        font-size: 1.2rem;
      }

      .control-button, #reset-button, #view-toggle, #focus-mode-button {
        font-size: 0.9rem;
        padding: 0.7rem 1.2rem;
      }

      .focus-view #reps {
        font-size: 20vw;
      }

      .focus-view #timer, .focus-view #rpm {
        font-size: 6vw;
      }
    }

    @media (max-width: 480px) {
      h1 {
        font-size: 1.8rem;
      }

      p {
        font-size: 0.9rem;
        margin-bottom: 1rem;
      }

      #reps-container {
        font-size: 1.8rem;
        padding: 0.8rem;
      }

      #reps {
        font-size: 2.2rem;
      }

      #timer, #rpm {
        font-size: 1rem;
      }

      .control-button, #reset-button, #view-toggle, #focus-mode-button {
        font-size: 0.8rem;
        padding: 0.6rem 1rem;
        margin: 0.3rem;
      }

      #goal-controls {
        flex-direction: column;
        gap: 10px;
      }

      .goal-input-wrapper {
        width: 100%;
        justify-content: center;
      }

      #nav-drawer {
        width: 100%;
        right: -100%;
      }

      .focus-view #reps {
        font-size: 18vw;
      }

      .focus-view #timer, .focus-view #rpm {
        font-size: 7vw;
      }
    }
  </style>
</head>
<body>
  <div id="loader">
    <div class="loader-content">
      <div class="loader-spinner"></div>
      <div class="loader-text">Loading OpenCV.js...</div>
      <div class="loader-progress">
        <div id="loader-progress"></div>
      </div>
      <div id="loader-percentage">0%</div>
      <div class="loader-message">Preparing your workout experience</div>
    </div>
  </div>

  <div class="container">
    <h1>Lacrosse Ball Rep Tracker</h1>
    <p>Use your camera to track lacrosse ball movement and count reps automatically.</p>

    <div id="reps-container">
      <div id="reps">Reps: 0</div>
      <div id="timer" style="display: none;">Time: 0s</div>
      <div id="rpm" style="display: none;">RPM: 0</div>
      <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin-top: 10px;">
        <button id="save-button" class="control-button">Save</button>
        <button id="reset-button">Reset</button>
      </div>
    </div>

    <div id="goal-container">
      <div id="goal-controls">
        <label for="goal-input">Goal:</label>
        <div class="goal-input-wrapper">
          <button class="goal-adjust-button" id="goal-minus">-</button>
          <input type="number" id="goal-input" min="10" max="500" value="100">
          <button class="goal-adjust-button" id="goal-plus">+</button>
        </div>
      </div>
      <div id="progress-bar-container">
        <div id="progress-bar"></div>
      </div>
    </div>

    <div id="menu-icon">
      <div></div>
      <div></div>
      <div></div>
    </div>

    <div id="nav-drawer">
      <div id="user-container" style="width: 80%; margin-bottom: 20px;">
        <span id="user-greeting" style="display: block; margin-bottom: 15px; font-weight: 500;"></span>
        <button id="login-button" class="control-button">Login/Sign Up</button>
        <button id="leaderboard-button" class="control-button">Leaderboard</button>
        <button id="session-history-button" class="control-button">History</button>
        <button id="view-toggle" class="control-button">Show Detection</button>
      </div>
      <div class="toggle-switch-container">
        <label for="timer-rpm-toggle">Show Timer/RPM</label>
        <label class="switch">
          <input type="checkbox" id="timer-rpm-toggle">
          <span class="slider"></span>
        </label>
      </div>
    </div>

    <canvas id="canvas"></canvas>

    <div id="controls-container">
      <button id="focus-mode-button" class="control-button">Focus Mode</button>
    </div>

    <div id="camera-status" style="display: none;">
      Requesting camera access...
    </div>

    <video id="video" autoplay playsinline muted></video>
    <div id="notification"></div>
    <button id="exit-focus-mode" class="control-button" style="display: none;">Exit Focus Mode</button>
  </div>

  <!-- Login Modal -->
  <div id="login-modal" class="modal">
    <div class="modal-content">
      <span class="close-button">&times;</span>
      <h2>Login or Sign Up</h2>
      <input type="text" id="username-input" placeholder="Enter your username">
      <input type="password" id="password-input" placeholder="Enter your password">
      <button id="login-submit" class="control-button">Go</button>
      <p id="login-error" style="color:red; display:none;"></p>
    </div>
  </div>

  <!-- Leaderboard Modal -->
  <div id="leaderboard-modal" class="modal">
    <div class="modal-content">
      <span class="close-button">&times;</span>
      <h2>Leaderboard</h2>
      <ol id="leaderboard-list"></ol>
    </div>
  </div>

  <!-- Session History Modal -->
  <div id="session-history-modal" class="modal">
    <div class="modal-content">
      <span class="close-button">&times;</span>
      <h2>Session History</h2>
      <ul id="session-history-list"></ul>
    </div>
  </div>

  <audio id="rep-sound" src="https://actions.google.com/sounds/v1/sports/tennis_ball_hit_bounce.ogg" preload="auto"></audio>

  <script>
    // Global variables
    let openCvReady = false;
    let domReady = false;
    let ballTracker = null;
    let reps = 0;
    let ballState = 'waiting'; // waiting, ball_present, ball_away, ball_returned
    let startTime = null;
    let lastThrowTime = 0; // Timestamp of the last counted throw
    let lastBallAbsentTime = 0; // Timestamp when the ball was last detected as absent
    let absentFrames = 0; // Counter for consecutive frames where the ball is absent

    // Rep counting parameters
    const minTimeBetweenThrows = 1000; // Minimum time in ms between two throws to be counted as separate reps
    const minAbsentTime = 500; // Minimum time in ms the ball must be absent to consider it a new throw
    const ballAbsentThreshold = 5; // Number of consecutive frames ball must be absent to trigger state change

    // Called when OpenCV.js is ready
    function onOpenCvReady() {
      openCvReady = true;
      console.log('OpenCV.js is ready');
      updateLoaderProgress(100, 'OpenCV.js loaded successfully');
      tryInitApp();
    }

    // Tries to initialize the app, called when either DOM or OpenCV is ready
    function tryInitApp() {
      if (domReady && openCvReady) {
        main().catch(err => {
          console.error('Initialization failed:', err);
          document.getElementById('reps').textContent = 'Error: ' + err.message;
        }).finally(() => {
          // Hide loader regardless of success or failure
          setTimeout(() => {
            document.getElementById('loader').style.opacity = '0';
            document.getElementById('loader').style.visibility = 'hidden';
          }, 500); // Give a moment for canvas to render
        });
      }
    }

    // Update loader progress
    function updateLoaderProgress(percentage, message) {
      const progressBar = document.getElementById('loader-progress');
      const percentageText = document.getElementById('loader-percentage');
      const loaderMessage = document.querySelector('.loader-message');
      
      progressBar.style.width = `${percentage}%`;
      percentageText.textContent = `${percentage}%`;
      
      if (message) {
        loaderMessage.textContent = message;
      }
    }

    // Setup camera with improved error handling
    async function setupCamera() {
      const video = document.getElementById('video');
      const cameraStatus = document.getElementById('camera-status');
      const repsDisplay = document.getElementById('reps');

      repsDisplay.textContent = 'Initializing...';
      cameraStatus.style.display = 'block';
      cameraStatus.innerHTML = 'Checking camera permissions...';

      try {
        // Add a timeout for the getUserMedia request
        const stream = await Promise.race([
          navigator.mediaDevices.getUserMedia({
            video: {
              width: { ideal: 1280 },
              height: { ideal: 720 },
              facingMode: 'user',
              frameRate: { ideal: 30 }
            }
          }),
          new Promise((_, reject) => setTimeout(() => reject(new Error('Camera request timed out')), 10000))
        ]);

        video.srcObject = stream;
        localStorage.setItem('wallBallCameraAccess', 'granted');
        cameraStatus.innerHTML = 'Camera access granted. Loading video...';
        
        await new Promise((resolve, reject) => {
          const timeout = setTimeout(() => reject(new Error('Video load timeout')), 10000);
          video.onloadedmetadata = () => {
            clearTimeout(timeout);
            video.width = video.videoWidth;
            video.height = video.videoHeight;
            resolve();
          };
        });

        await video.play();
        cameraStatus.style.display = 'none';
        return video;
      } catch (err) {
        localStorage.setItem('wallBallCameraAccess', 'denied');
        cameraStatus.innerHTML = 
          `Camera access failed: ${err.message}. <button onclick="requestCameraAgain()" class="control-button" style="padding: 5px 10px; font-size: 0.9rem;">Try Again</button>`;
        repsDisplay.textContent = 'Camera Error';
        console.error('Camera error:', err);
        throw err;
      }
    }
    
    // Request camera access again
    function requestCameraAgain() {
      document.getElementById('camera-status').innerHTML = 'Requesting camera access...';
      main().catch(err => {
        console.error('Failed to initialize after retry:', err);
      });
    }

    // Draw circle helper function
    function drawCircle(ctx, x, y, radius, color, thickness = 2) {
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.strokeStyle = color;
      ctx.lineWidth = thickness;
      ctx.stroke();
    }
    
    // Draw ball detection visualization
    function drawBallDetection(detectedBalls, ctx) {
      detectedBalls.forEach((ball, index) => {
        // Draw circle around detected ball
        drawCircle(ctx, ball.x, ball.y, ball.radius, '#00FF00', 3);
        
        // Draw center point
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, 3, 0, 2 * Math.PI);
        ctx.fillStyle = '#FF0000';
        ctx.fill();
        
        // Draw confidence score
        ctx.fillStyle = '#FFFFFF';
        ctx.font = '16px Poppins';
        ctx.fillText(`Ball ${index + 1}`, ball.x - 20, ball.y - ball.radius - 10);
      });
    }
    
    // Lacrosse Ball Tracker Class
    class LacrosseBallTracker {
      constructor() {
        this.previousBalls = [];
        this.ballHistory = {};
        this.maxHistoryLength = 10;
        
        // Lacrosse ball specific parameters (regulation ball is 2.5 inches diameter)
        this.minBallRadius = 20;  // Minimum radius for lacrosse ball detection
        this.maxBallRadius = 60;  // Maximum radius for lacrosse ball detection
        this.idealBallRadius = 30; // Ideal lacrosse ball radius in pixels
        this.movementThreshold = 15; // Minimum movement to consider as significant
        this.maxTrackingDistance = 180; // Maximum distance to track same ball
        
        // Detection quality thresholds
        this.minDetectionScore = 0.3; // Minimum score to accept a detection
        this.colorMatchThreshold = 0.2; // Minimum color match percentage
        
        // Lacrosse ball color ranges in HSV
        this.colorRanges = {
          white: { lower: [0, 0, 200], upper: [180, 30, 255] },
          yellow: { lower: [20, 100, 100], upper: [30, 255, 255] },
          orange: { lower: [10, 100, 100], upper: [20, 255, 255] }
        };
        
        this.initialized = false;
      }
      
      initialize() {
        if (openCvReady) {
          this.initialized = true;
          console.log('Ball tracker initialized');
        }
      }
      
      detectBalls(videoElement) {
        if (!this.initialized || !openCvReady) {
          return [];
        }
        
        try {
          // Create OpenCV matrices
          const src = new cv.Mat(videoElement.height, videoElement.width, cv.CV_8UC4);
          const gray = new cv.Mat();
          const hsv = new cv.Mat();
          const mask = new cv.Mat();
          const blurred = new cv.Mat();
          const circles = new cv.Mat();
          
          // Capture frame from video
          const cap = new cv.VideoCapture(videoElement);
          cap.read(src);
          
          // Convert to HSV for better color filtering
          cv.cvtColor(src, hsv, cv.COLOR_RGBA2RGB);
          cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);
          
          // Create mask for lacrosse ball colors (white, yellow, orange)
          // White range
          const whiteLower = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [0, 0, 200, 0]);
          const whiteUpper = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [180, 30, 255, 255]);
          const whiteMask = new cv.Mat();
          cv.inRange(hsv, whiteLower, whiteUpper, whiteMask);
          
          // Yellow range
          const yellowLower = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [20, 100, 100, 0]);
          const yellowUpper = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [30, 255, 255, 255]);
          const yellowMask = new cv.Mat();
          cv.inRange(hsv, yellowLower, yellowUpper, yellowMask);
          
          // Orange range
          const orangeLower = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [10, 100, 100, 0]);
          const orangeUpper = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [20, 255, 255, 255]);
          const orangeMask = new cv.Mat();
          cv.inRange(hsv, orangeLower, orangeUpper, orangeMask);
          
          // Combine all color masks
          cv.bitwise_or(whiteMask, yellowMask, mask);
          cv.bitwise_or(mask, orangeMask, mask);
          
          // Apply morphological operations to clean up the mask
          const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(5, 5));
          cv.morphologyEx(mask, mask, cv.MORPH_CLOSE, kernel);
          cv.morphologyEx(mask, mask, cv.MORPH_OPEN, kernel);
          
          // Convert to grayscale and apply mask
          cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
          cv.bitwise_and(gray, mask, gray);
          
          // Apply Gaussian blur with lacrosse ball specific parameters
          cv.GaussianBlur(gray, blurred, new cv.Size(7, 7), 1.5, 1.5);
          
          // Enhanced HoughCircles parameters specifically tuned for lacrosse balls
          cv.HoughCircles(
            blurred,
            circles,
            cv.HOUGH_GRADIENT,
            1,              // dp: inverse ratio of accumulator resolution
            100,            // minDist: minimum distance between circle centers
            100,            // param1: upper threshold for edge detection
            30,             // param2: accumulator threshold for center detection
            this.minBallRadius,  // minRadius
            this.maxBallRadius   // maxRadius
          );
          
          let bestBall = null;
          let bestScore = 0;
          
          // Process detected circles with lacrosse ball specific validation
          for (let i = 0; i < circles.cols; i++) {
            const x = circles.data32F[i * 3];
            const y = circles.data32F[i * 3 + 1];
            const radius = circles.data32F[i * 3 + 2];
            
            // Enhanced validation for lacrosse balls
            if (this.isValidLacrosseBall(x, y, radius, videoElement.width, videoElement.height, mask)) {
              // Calculate comprehensive quality score
              const lacrosseBallScore = this.calculateLacrosseBallScore(x, y, radius, videoElement, mask);
              
              // Only accept detections above minimum quality threshold
              if (lacrosseBallScore > this.minDetectionScore && lacrosseBallScore > bestScore) {
                bestScore = lacrosseBallScore;
                bestBall = { x, y, radius, timestamp: Date.now(), score: lacrosseBallScore };
              }
            }
          }
          
          // Clean up OpenCV matrices
          src.delete();
          gray.delete();
          hsv.delete();
          mask.delete();
          blurred.delete();
          circles.delete();
          whiteLower.delete();
          whiteUpper.delete();
          whiteMask.delete();
          yellowLower.delete();
          yellowUpper.delete();
          yellowMask.delete();
          orangeLower.delete();
          orangeUpper.delete();
          orangeMask.delete();
          kernel.delete();
          
          // Return single best ball or empty array
          return bestBall ? [bestBall] : [];
          
        } catch (error) {
          console.error('Lacrosse ball detection error:', error);
          return [];
        }
      }
      
      isValidBall(x, y, radius, frameWidth, frameHeight) {
        // Check if ball is within frame bounds
        if (x - radius < 0 || x + radius > frameWidth || 
            y - radius < 0 || y + radius > frameHeight) {
          return false;
        }
        
        // Check if radius is within expected range
        if (radius < this.minBallRadius || radius > this.maxBallRadius) {
          return false;
        }
        
        return true;
      }
      
      isValidLacrosseBall(x, y, radius, frameWidth, frameHeight, colorMask) {
        // Basic boundary and size validation
        if (!this.isValidBall(x, y, radius, frameWidth, frameHeight)) {
          return false;
        }
        
        try {
          // Check if the detected circle area has sufficient color match
          const roi = new cv.Rect(
            Math.max(0, x - radius), 
            Math.max(0, y - radius), 
            Math.min(frameWidth - Math.max(0, x - radius), radius * 2),
            Math.min(frameHeight - Math.max(0, y - radius), radius * 2)
          );
          const maskRoi = colorMask.roi(roi);
          
          // Calculate the percentage of pixels that match lacrosse ball colors
          const totalPixels = maskRoi.rows * maskRoi.cols;
          const whitePixels = cv.countNonZero(maskRoi);
          const colorMatchPercentage = whitePixels / totalPixels;
          
          maskRoi.delete();
          
          // Require minimum color match percentage for lacrosse ball
          return colorMatchPercentage > this.colorMatchThreshold;
          
        } catch (error) {
          console.warn('Color validation error:', error);
          return true; // Fall back to basic validation
        }
      }
      
      calculateLacrosseBallScore(x, y, radius, videoElement, colorMask) {
        try {
          // 1. Radius score - prefer balls close to standard lacrosse ball size
          const radiusScore = Math.max(0, 1 - Math.abs(radius - this.idealBallRadius) / this.idealBallRadius);
          
          // 2. Circularity score - lacrosse balls should be perfectly circular
          const circularityScore = this.calculateCircularity(x, y, radius, videoElement);
          
          // 3. Color consistency score
          const colorScore = this.calculateColorConsistency(x, y, radius, colorMask);
          
          // 4. Position preference (center of frame)
          const centerX = videoElement.width / 2;
          const centerY = videoElement.height / 2;
          const distanceFromCenter = Math.sqrt(
            Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2)
          );
          const maxDistance = Math.sqrt(Math.pow(centerX, 2) + Math.pow(centerY, 2));
          const positionScore = 1 - (distanceFromCenter / maxDistance);
          
          // 5. Edge strength score
          const edgeScore = this.calculateEdgeStrength(x, y, radius, videoElement);
          
          // Weighted combination optimized for lacrosse ball detection
          const totalScore = (
            radiusScore * 0.25 +      // Size is important
            circularityScore * 0.25 +  // Shape is crucial
            colorScore * 0.30 +        // Color is very important
            positionScore * 0.10 +     // Position preference
            edgeScore * 0.10           // Edge definition
          );
          
          return totalScore;
          
        } catch (error) {
          console.warn('Score calculation error:', error);
          return 0.5; // Default moderate score
        }
      }
      
      calculateCircularity(x, y, radius, videoElement) {
        // For now, return a high score since HoughCircles already filters for circular shapes
        // In a more advanced implementation, we could analyze the actual contour
        return 0.9;
      }
      
      calculateColorConsistency(x, y, radius, colorMask) {
        try {
          const roi = new cv.Rect(
            Math.max(0, x - radius), 
            Math.max(0, y - radius), 
            Math.min(colorMask.cols - Math.max(0, x - radius), radius * 2),
            Math.min(colorMask.rows - Math.max(0, y - radius), radius * 2)
          );
          const maskRoi = colorMask.roi(roi);
          
          const totalPixels = maskRoi.rows * maskRoi.cols;
          const matchingPixels = cv.countNonZero(maskRoi);
          const consistency = matchingPixels / totalPixels;
          
          maskRoi.delete();
          return Math.min(1.0, consistency * 2); // Boost the score for good color matches
          
        } catch (error) {
          return 0.5;
        }
      }
      
      calculateEdgeStrength(x, y, radius, videoElement) {
        // Simplified edge strength calculation
        // In a full implementation, we could use Sobel operators
        return 0.8; // Default good edge score
      }
      
      filterAndTrackBalls(detectedBalls) {
        const currentTime = Date.now();
        
        // Since we only track one ball, simplify the logic
        if (detectedBalls.length === 0) {
          this.previousBalls = [];
          return [];
        }
        
        const ball = detectedBalls[0]; // Only one ball
        let trackedBall;
        
        // Check if we have a previous ball to track from
        if (this.previousBalls.length > 0) {
          const prevBall = this.previousBalls[0];
          const distance = Math.sqrt(
            Math.pow(ball.x - prevBall.x, 2) + 
            Math.pow(ball.y - prevBall.y, 2)
          );
          
          // If the ball moved too far, treat as new detection
          if (distance > this.maxTrackingDistance) {
            trackedBall = {
              ...ball,
              id: Math.random().toString(36).substr(2, 9),
              velocity: { x: 0, y: 0, magnitude: 0 }
            };
          } else {
            // Continue tracking the same ball
            trackedBall = {
              ...ball,
              id: prevBall.id,
              velocity: {
                x: ball.x - prevBall.x,
                y: ball.y - prevBall.y,
                magnitude: Math.sqrt(
                  Math.pow(ball.x - prevBall.x, 2) + 
                  Math.pow(ball.y - prevBall.y, 2)
                )
              }
            };
          }
        } else {
          // First detection
          trackedBall = {
            ...ball,
            id: Math.random().toString(36).substr(2, 9),
            velocity: { x: 0, y: 0, magnitude: 0 }
          };
        }
        
        // Update previous balls for next frame
        this.previousBalls = [trackedBall];
        
        // Update ball history for movement analysis
        this.updateBallHistory([trackedBall]);
        
        return [trackedBall];
      }
      
      updateBallHistory(balls) {
        const currentTime = Date.now();
        
        // Since we only track one ball, simplify history management
        if (balls.length === 0) {
          // Clear history if no ball detected
          this.ballHistory = {};
          return;
        }
        
        const ball = balls[0]; // Only one ball
        
        if (!this.ballHistory[ball.id]) {
          this.ballHistory[ball.id] = [];
        }
        
        this.ballHistory[ball.id].push({
          x: ball.x,
          y: ball.y,
          timestamp: currentTime,
          velocity: ball.velocity || { x: 0, y: 0, magnitude: 0 }
        });
        
        // Keep only recent history (last 2 seconds)
        const cutoffTime = currentTime - 2000;
        this.ballHistory[ball.id] = this.ballHistory[ball.id].filter(
          point => point.timestamp > cutoffTime
        );
        
        // Clean up old ball histories (keep only current ball)
        Object.keys(this.ballHistory).forEach(ballId => {
          if (ballId !== ball.id) {
            delete this.ballHistory[ballId];
          }
        });
      }
      
      analyzeMovementPattern() {
        // Get the current ball's history
        const ballIds = Object.keys(this.ballHistory);
        if (ballIds.length === 0) {
          return { isThrow: false, direction: null };
        }
        
        const ballId = ballIds[0]; // Only one ball
        const history = this.ballHistory[ballId];
        
        if (history.length < 3) {
          return { isThrow: false, direction: null };
        }
        
        const recent = history.slice(-5); // Last 5 points
        let totalMovement = 0;
        let verticalMovement = 0;
        
        for (let i = 1; i < recent.length; i++) {
          const prev = recent[i-1];
          const curr = recent[i];
          
          const dx = curr.x - prev.x;
          const dy = curr.y - prev.y;
          const movement = Math.sqrt(dx*dx + dy*dy);
          
          totalMovement += movement;
          verticalMovement += Math.abs(dy);
        }
        
        const avgMovement = totalMovement / (recent.length - 1);
        const isSignificantMovement = avgMovement > this.movementThreshold;
        const isVerticalMovement = verticalMovement > totalMovement * 0.4;
        
        return {
          isThrow: isSignificantMovement && isVerticalMovement,
          direction: verticalMovement > 0 ? 'down' : 'up',
          movement: avgMovement
        };
      }

      reset() {
        this.ballHistory = {};
        this.previousBalls = [];
      }
    }

    // Reset rep counter
    function resetReps() {
      reps = 0;
      ballState = 'waiting';
      startTime = null;
      document.getElementById('reps').textContent = 'Reps: 0';
      document.getElementById('timer').textContent = 'Time: 0s';
      document.getElementById('rpm').textContent = 'RPM: 0';
      document.getElementById('progress-bar').style.width = '0%';
      
      if (ballTracker) {
        ballTracker.reset();
      }
    }

    // Update progress bar
    function updateProgressBar() {
      const goal = parseInt(document.getElementById('goal-input').value);
      const progress = (reps / goal) * 100;
      document.getElementById('progress-bar').style.width = `${Math.min(progress, 100)}%`;
    }

    // Update timer and RPM display
    function updateTimerAndRPM() {
      if (!startTime) return;
      
      const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
      document.getElementById('timer').textContent = `Time: ${elapsedSeconds}s`;

      if (elapsedSeconds > 0) {
        const rpm = Math.round((reps / elapsedSeconds) * 60);
        document.getElementById('rpm').textContent = `RPM: ${rpm}`;
      }
    }

    // Show notification
    function showNotification(message) {
      const notification = document.getElementById('notification');
      notification.textContent = message;
      notification.classList.add('show');
      
      setTimeout(() => {
        notification.classList.remove('show');
      }, 3000);
    }

    // Main detection loop
    async function detect(video, canvas) {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      updateTimerAndRPM();

      if (ballTracker && ballTracker.initialized) {
        const detectedBalls = ballTracker.detectBalls(video);
        const trackedBalls = ballTracker.filterAndTrackBalls(detectedBalls);
        const detectedBall = trackedBalls.length > 0 ? trackedBalls[0] : null;
        const currentTime = Date.now();

        // Show detection visualization if enabled
        if (window.showDetection && detectedBall) {
          drawBallDetection([detectedBall], ctx);
        }

        // Rep counting state machine
        switch (ballState) {
          case 'waiting':
            if (detectedBall) {
              ballState = 'ball_present';
              if (!startTime) {
                startTime = Date.now();
              }
            }
            break;
            
          case 'ball_present':
            if (!detectedBall) {
              absentFrames++;
              if (absentFrames >= ballAbsentThreshold) {
                ballState = 'ball_away';
                lastBallAbsentTime = currentTime;
                absentFrames = 0;
              }
            } else {
              absentFrames = 0;
            }
            break;
            
          case 'ball_away':
            if (detectedBall) {
              if (currentTime - lastBallAbsentTime > minAbsentTime && 
                  currentTime - lastThrowTime > minTimeBetweenThrows) {
                ballState = 'ball_returned';
              } else {
                // Ball returned too quickly, likely a flicker, go back to present
                ballState = 'ball_present';
              }
            }
            break;
            
          case 'ball_returned':
            reps++;
            lastThrowTime = currentTime;
            
            document.getElementById('reps').textContent = 'Reps: ' + reps;
            const repSound = document.getElementById('rep-sound');
            repSound.currentTime = 0;
            repSound.play().catch(e => console.error('Audio play failed:', e));
            updateProgressBar();
            
            // Show visual feedback for a short duration
            ctx.fillStyle = '#00FF00';
            ctx.font = 'bold 48px Poppins';
            ctx.textAlign = 'center';
            ctx.fillText('REP!', canvas.width / 2, canvas.height / 2);
            ctx.textAlign = 'left';
            
            ballState = 'ball_present'; // Immediately go back to present
            break;
        }

        // Display current state for debugging
        if (window.showDetection) {
          ctx.fillStyle = '#FFFFFF';
          ctx.font = '16px Poppins';
          ctx.fillText(`State: ${ballState}`, 10, 30);
          ctx.fillText(`Detected: ${detectedBall ? 'Yes' : 'No'}`, 10, 50);
          ctx.fillText(`Last Throw: ${Math.round((currentTime - lastThrowTime)/1000)}s ago`, 10, 70);
        }
      } else {
        // OpenCV not ready, show status
        ctx.fillStyle = '#FFFF00';
        ctx.font = '20px Poppins';
        ctx.textAlign = 'center';
        ctx.fillText('Loading ball detection...', canvas.width / 2, canvas.height / 2);
        ctx.textAlign = 'left';
      }
      
      if (window.ballDetectionActive) {
        requestAnimationFrame(() => detect(video, canvas));
      }
    }

    // Main initialization function
    async function main() {
      try {
        // Setup camera
        const video = await setupCamera();
        const canvas = document.getElementById('canvas');
        canvas.width = video.width;
        canvas.height = video.height;

        // Initialize ball tracker
        ballTracker = new LacrosseBallTracker();
        if (openCvReady) {
          ballTracker.initialize();
        }

        // Initialize UI
        window.showDetection = false;
        const viewToggleButton = document.getElementById('view-toggle');
        viewToggleButton.addEventListener('click', () => {
          window.showDetection = !window.showDetection;
          viewToggleButton.textContent = window.showDetection ? 'Hide Detection' : 'Show Detection';
        });

        // Start detection loop
        window.ballDetectionActive = true;
        detect(video, canvas);

        // Setup UI event listeners
        setupUI();
      } catch (error) {
        console.error('Camera setup failed:', error);
        
        // Show error message to user
        const repsDisplay = document.getElementById('reps');
        repsDisplay.textContent = 'Camera setup failed';
      }
    }

    // Setup UI event listeners
    function setupUI() {
      // Goal input controls
      const goalInput = document.getElementById('goal-input');
      const goalPlus = document.getElementById('goal-plus');
      const goalMinus = document.getElementById('goal-minus');
      
      goalInput.addEventListener('input', updateProgressBar);
      
      goalPlus.addEventListener('click', () => {
        goalInput.value = parseInt(goalInput.value) + 10;
        updateProgressBar();
      });
      
      goalMinus.addEventListener('click', () => {
        goalInput.value = Math.max(10, parseInt(goalInput.value) - 10);
        updateProgressBar();
      });

      // Reset button
      document.getElementById('reset-button').addEventListener('click', () => {
        if (confirm('Are you sure you want to reset? This will clear all current progress.')) {
          resetReps();
        }
      });

      // Save button
      document.getElementById('save-button').addEventListener('click', () => {
        saveSession();
        showNotification('Session saved!');
      });

      // Focus mode
      const focusModeButton = document.getElementById('focus-mode-button');
      const exitFocusModeButton = document.getElementById('exit-focus-mode');
      
      focusModeButton.addEventListener('click', () => {
        document.body.classList.add('focus-view');
        exitFocusModeButton.style.display = 'block';
      });
      
      exitFocusModeButton.addEventListener('click', () => {
        document.body.classList.remove('focus-view');
        exitFocusModeButton.style.display = 'none';
      });

      // Menu icon
      const menuIcon = document.getElementById('menu-icon');
      const navDrawer = document.getElementById('nav-drawer');
      
      menuIcon.addEventListener('click', () => {
        menuIcon.classList.toggle('open');
        navDrawer.classList.toggle('open');
      });

      // Timer/RPM toggle
      const timerRpmToggle = document.getElementById('timer-rpm-toggle');
      const timerDisplay = document.getElementById('timer');
      const rpmDisplay = document.getElementById('rpm');
      
      timerRpmToggle.addEventListener('change', () => {
        if (timerRpmToggle.checked) {
          timerDisplay.style.display = 'block';
          rpmDisplay.style.display = 'block';
        } else {
          timerDisplay.style.display = 'none';
          rpmDisplay.style.display = 'none';
        }
      });

      // Modal controls
      setupModals();
      
      // Load current user if available
      loadCurrentUser();
    }

    // Setup modals
    function setupModals() {
      // Login modal
      const loginModal = document.getElementById('login-modal');
      const loginButton = document.getElementById('login-button');
      const loginCloseButton = loginModal.querySelector('.close-button');
      const loginSubmit = document.getElementById('login-submit');
      
      loginButton.addEventListener('click', () => {
        loginModal.classList.add('show');
      });
      
      loginCloseButton.addEventListener('click', () => {
        loginModal.classList.remove('show');
      });
      
      loginSubmit.addEventListener('click', () => {
        login();
      });
      
      // Leaderboard modal
      const leaderboardModal = document.getElementById('leaderboard-modal');
      const leaderboardButton = document.getElementById('leaderboard-button');
      const leaderboardCloseButton = leaderboardModal.querySelector('.close-button');
      
      leaderboardButton.addEventListener('click', () => {
        updateLeaderboard();
        leaderboardModal.classList.add('show');
      });
      
      leaderboardCloseButton.addEventListener('click', () => {
        leaderboardModal.classList.remove('show');
      });
      
      // Session history modal
      const sessionHistoryModal = document.getElementById('session-history-modal');
      const sessionHistoryButton = document.getElementById('session-history-button');
      const sessionHistoryCloseButton = sessionHistoryModal.querySelector('.close-button');
      
      sessionHistoryButton.addEventListener('click', () => {
        updateSessionHistory();
        sessionHistoryModal.classList.add('show');
      });
      
      sessionHistoryCloseButton.addEventListener('click', () => {
        sessionHistoryModal.classList.remove('show');
      });
      
      // Close modals when clicking outside
      window.addEventListener('click', (event) => {
        if (event.target === loginModal) {
          loginModal.classList.remove('show');
        } else if (event.target === leaderboardModal) {
          leaderboardModal.classList.remove('show');
        } else if (event.target === sessionHistoryModal) {
          sessionHistoryModal.classList.remove('show');
        }
      });
    }

    // Login function
    function login() {
      const username = document.getElementById('username-input').value.trim();
      const password = document.getElementById('password-input').value.trim();
      const loginError = document.getElementById('login-error');
      
      if (!username || !password) {
        loginError.textContent = 'Please enter both username and password';
        loginError.style.display = 'block';
        return;
      }
      
      // Simple client-side authentication (for demo purposes)
      // In a real app, this would be a server request
      let users = JSON.parse(localStorage.getItem('wallBallUsers') || '{}');
      
      if (!users[username]) {
        // New user registration
        users[username] = {
          password: password, // In a real app, this would be hashed
          sessions: [],
          highScore: 0
        };
        localStorage.setItem('wallBallUsers', JSON.stringify(users));
        localStorage.setItem('wallBallCurrentUser', username);
        document.getElementById('login-modal').classList.remove('show');
        loadCurrentUser();
        showNotification('Welcome, new user created!');
      } else if (users[username].password === password) {
        // Existing user login
        localStorage.setItem('wallBallCurrentUser', username);
        document.getElementById('login-modal').classList.remove('show');
        loadCurrentUser();
        showNotification('Welcome back!');
      } else {
        // Incorrect password
        loginError.textContent = 'Incorrect password';
        loginError.style.display = 'block';
      }
    }

    // Load current user
    function loadCurrentUser() {
      const currentUser = localStorage.getItem('wallBallCurrentUser');
      const userGreeting = document.getElementById('user-greeting');
      const loginButton = document.getElementById('login-button');
      
      if (currentUser) {
        userGreeting.textContent = `Hello, ${currentUser}!`;
        loginButton.textContent = 'Logout';
        loginButton.removeEventListener('click', null);
        loginButton.addEventListener('click', logout);
      } else {
        userGreeting.textContent = 'Not logged in';
        loginButton.textContent = 'Login/Sign Up';
      }
    }

    // Logout function
    function logout() {
      localStorage.removeItem('wallBallCurrentUser');
      loadCurrentUser();
      showNotification('Logged out successfully');
    }

    // Save session
    function saveSession() {
      const currentUser = localStorage.getItem('wallBallCurrentUser');
      if (!currentUser) {
        showNotification('Please login to save your session');
        document.getElementById('login-modal').classList.add('show');
        return;
      }
      
      if (reps === 0) {
        showNotification('No reps to save');
        return;
      }
      
      const users = JSON.parse(localStorage.getItem('wallBallUsers') || '{}');
      const user = users[currentUser];
      
      if (!user) {
        showNotification('User data error. Please login again.');
        return;
      }
      
      // Calculate session duration
      const duration = startTime ? Math.floor((Date.now() - startTime) / 1000) : 0;
      
      // Create session object
      const session = {
        reps: reps,
        duration: duration,
        rpm: duration > 0 ? Math.round((reps / duration) * 60) : 0,
        date: new Date().toISOString(),
        goal: parseInt(document.getElementById('goal-input').value)
      };
      
      // Add to user's sessions
      user.sessions.unshift(session); // Add to beginning of array
      
      // Keep only the last 10 sessions
      if (user.sessions.length > 10) {
        user.sessions = user.sessions.slice(0, 10);
      }
      
      // Update high score if needed
      if (reps > user.highScore) {
        user.highScore = reps;
        showNotification('New high score! ');
      }
      
      // Save updated user data
      localStorage.setItem('wallBallUsers', JSON.stringify(users));
      
      // Reset reps for new session
      resetReps();
    }

    // Update leaderboard
    function updateLeaderboard() {
      const leaderboardList = document.getElementById('leaderboard-list');
      leaderboardList.innerHTML = '';
      
      const users = JSON.parse(localStorage.getItem('wallBallUsers') || '{}');
      
      // Convert to array and sort by high score
      const sortedUsers = Object.entries(users)
        .map(([username, data]) => ({ username, highScore: data.highScore }))
        .sort((a, b) => b.highScore - a.highScore);
      
      if (sortedUsers.length === 0) {
        leaderboardList.innerHTML = '<li>No scores yet</li>';
        return;
      }
      
      // Create leaderboard items
      sortedUsers.forEach((user, index) => {
        if (user.highScore > 0) {
          const li = document.createElement('li');
          li.innerHTML = `<strong>${index + 1}. ${user.username}</strong>: ${user.highScore} reps`;
          leaderboardList.appendChild(li);
        }
      });
    }

    // Update session history
    function updateSessionHistory() {
      const sessionHistoryList = document.getElementById('session-history-list');
      sessionHistoryList.innerHTML = '';
      
      const currentUser = localStorage.getItem('wallBallCurrentUser');
      if (!currentUser) {
        sessionHistoryList.innerHTML = '<li>Please login to view your history</li>';
        return;
      }
      
      const users = JSON.parse(localStorage.getItem('wallBallUsers') || '{}');
      const user = users[currentUser];
      
      if (!user || !user.sessions || user.sessions.length === 0) {
        sessionHistoryList.innerHTML = '<li>No sessions recorded yet</li>';
        return;
      }
      
      // Create session history items
      user.sessions.forEach((session, index) => {
        const date = new Date(session.date).toLocaleDateString();
        const time = new Date(session.date).toLocaleTimeString();
        const li = document.createElement('li');
        li.innerHTML = `
          <strong>${date} at ${time}</strong><br>
          Reps: ${session.reps} | Duration: ${session.duration}s | RPM: ${session.rpm}
        `;
        sessionHistoryList.appendChild(li);
      });
    }

    // Check for browser compatibility
    function checkBrowserCompatibility() {
      const warnings = [];
      
      // Check for WebAssembly support (needed for OpenCV.js)
      if (typeof WebAssembly !== 'object') {
        warnings.push('WebAssembly is not supported in your browser. OpenCV.js requires WebAssembly.');
      }
      
      // Check for camera API
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        warnings.push('Camera access is not supported in your browser.');
      }
      
      // Check for Canvas API
      if (!document.createElement('canvas').getContext) {
        warnings.push('Canvas is not supported in your browser.');
      }
      
      // Check for localStorage
      try {
        localStorage.setItem('test', 'test');
        localStorage.removeItem('test');
      } catch (e) {
        warnings.push('LocalStorage is not available. User data cannot be saved.');
      }
      
      // Mobile-specific warnings
      if (/Mobi|Android/i.test(navigator.userAgent)) {
        // iOS Safari specific warnings
        if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream) {
          warnings.push('On iOS, please use Safari for best performance and allow camera access when prompted.');
        }
        
        // Android Chrome specific warnings
        if (/Android/i.test(navigator.userAgent) && /Chrome/i.test(navigator.userAgent)) {
          warnings.push('On Android, please keep the app open in the foreground for best performance.');
        }
        
        // Memory warning for mobile devices
        warnings.push('This app uses computer vision which may be resource-intensive on mobile devices.');
      }
      
      return warnings;
    }

    // Window load event
    window.onload = function() {
      // Check browser compatibility
      const warnings = checkBrowserCompatibility();
      if (warnings.length > 0) {
        const warningMessage = warnings.join('\n ');
        alert('Compatibility Notice:\n\n ' + warningMessage);
      }
      
      domReady = true;
      tryInitApp();
    };

    // Handle double-tap on mobile to close sidebar
    let lastTap = 0;
    document.addEventListener('touchend', function(event) {
      const currentTime = new Date().getTime();
      const tapLength = currentTime - lastTap;
      if (tapLength < 500 && tapLength > 0) {
        // Double tap detected
        if (document.getElementById('nav-drawer').classList.contains('open')) {
          document.getElementById('nav-drawer').classList.remove('open');
          document.getElementById('menu-icon').classList.remove('open');
        }
      }
      lastTap = currentTime;
    });
