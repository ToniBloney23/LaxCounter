<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#1a1a2e">
  <meta name="format-detection" content="telephone=no">
  <title>Lax Counter</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <!-- OpenCV.js is loaded dynamically with progress tracking in the JavaScript code -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      --primary: #4361ee;
      --secondary: #3a0ca3;
      --accent: #4cc9f0;
      --success: #2ec4b6;
      --warning: #ff9f1c;
      --danger: #e71d36;
      --dark: #1a1a2e;
      --light: #f8f9fa;
      --gray: #6c757d;
      --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Montserrat', sans-serif;
      background-color: var(--dark);
      color: var(--light);
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .app-container {
      display: grid;
      grid-template-columns: 280px 1fr;
      min-height: 100vh;
      position: relative;
    }

    /* Sidebar Styles */
    .sidebar {
      background-color: rgba(26, 26, 46, 0.95);
      padding: 2rem 1.5rem;
      display: flex;
      flex-direction: column;
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      position: sticky;
      top: 0;
      height: 100vh;
      overflow-y: auto;
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      z-index: 100;
      transition: var(--transition);
    }

    .sidebar-collapsed {
      transform: translateX(-280px);
    }

    .logo {
      display: flex;
      align-items: center;
      margin-bottom: 2.5rem;
      gap: 0.75rem;
    }

    .logo-icon {
      width: 2.5rem;
      height: 2.5rem;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 1.2rem;
    }

    .logo-text {
      font-size: 1.25rem;
      font-weight: 600;
      color: white;
    }

    .nav-section {
      margin-bottom: 2rem;
    }

    .nav-section-title {
      text-transform: uppercase;
      font-size: 0.75rem;
      letter-spacing: 1px;
      color: var(--gray);
      margin-bottom: 1rem;
      padding-left: 0.5rem;
    }

    .nav-item {
      display: flex;
      align-items: center;
      padding: 0.75rem 1rem;
      border-radius: 8px;
      margin-bottom: 0.5rem;
      cursor: pointer;
      transition: var(--transition);
      color: rgba(255, 255, 255, 0.7);
    }

    .nav-item:hover {
      background-color: rgba(255, 255, 255, 0.1);
      color: white;
    }

    .nav-item.active {
      background-color: var(--primary);
      color: white;
    }

    .nav-icon {
      margin-right: 0.75rem;
      font-size: 1.2rem;
      width: 1.5rem;
      text-align: center;
    }

    .user-profile {
      margin-top: auto;
      display: flex;
      align-items: center;
      padding: 1rem;
      border-radius: 12px;
      background-color: rgba(255, 255, 255, 0.05);
    }

    .user-avatar {
      width: 2.5rem;
      height: 2.5rem;
      border-radius: 50%;
      background-color: var(--accent);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      margin-right: 0.75rem;
    }

    .user-info {
      flex: 1;
    }

    .user-name {
      font-weight: 600;
      font-size: 0.9rem;
    }

    .user-status {
      font-size: 0.75rem;
      color: var(--gray);
    }

    /* Main Content Styles */
    .main-content {
      padding: 2rem;
      position: relative;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 2rem;
    }

    .menu-toggle {
      width: 2.5rem;
      height: 2.5rem;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: var(--transition);
    }

    .menu-toggle:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }

    .page-title {
      font-size: 1.75rem;
      font-weight: 700;
      background: linear-gradient(to right, var(--primary), var(--accent));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      margin-bottom: 0.5rem;
    }

    .page-subtitle {
      color: var(--gray);
      font-size: 1rem;
    }

    .action-buttons {
      display: flex;
      gap: 1rem;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      border: none;
      font-family: inherit;
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .btn-primary {
      background-color: var(--primary);
      color: white;
    }

    .btn-primary:hover {
      background-color: var(--secondary);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(67, 97, 238, 0.3);
    }

    .btn-outline {
      background-color: transparent;
      color: var(--light);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .btn-outline:hover {
      background-color: rgba(255, 255, 255, 0.1);
      transform: translateY(-2px);
    }

    .btn-danger {
      background-color: var(--danger);
      color: white;
    }

    .btn-danger:hover {
      background-color: #c41c2e;
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(231, 29, 54, 0.3);
    }

    .btn-icon {
      width: 2.5rem;
      height: 2.5rem;
      padding: 0;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
    }

    /* Dashboard Grid */
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1.5rem;
      margin-bottom: 2rem;
    }

    .card {
      background-color: rgba(26, 26, 46, 0.8);
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
      transition: var(--transition);
      border: 1px solid rgba(255, 255, 255, 0.1);
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
    }

    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }

    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1rem;
    }

    .card-title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--light);
    }

    .card-icon {
      width: 2.5rem;
      height: 2.5rem;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
    }

    .card-icon-primary {
      background-color: rgba(67, 97, 238, 0.2);
      color: var(--primary);
    }

    .card-icon-success {
      background-color: rgba(46, 196, 182, 0.2);
      color: var(--success);
    }

    .card-icon-warning {
      background-color: rgba(255, 159, 28, 0.2);
      color: var(--warning);
    }

    .card-icon-danger {
      background-color: rgba(231, 29, 54, 0.2);
      color: var(--danger);
    }

    .stat-value {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    .stat-label {
      font-size: 0.85rem;
      color: var(--gray);
    }

    .stat-change {
      display: flex;
      align-items: center;
      font-size: 0.85rem;
      margin-top: 0.5rem;
    }

    .stat-change-positive {
      color: var(--success);
    }

    .stat-change-negative {
      color: var(--danger);
    }

    /* Video Container */
    .video-container {
      position: relative;
      margin-bottom: 2rem;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
    }

    #video-canvas {
      width: 100%;
      height: auto;
      display: block;
      background-color: #000;
    }

    #video {
      display: none;
    }

    .video-overlay {
      position: absolute;
      top: 1.5rem;
      right: 1.5rem;
      display: flex;
      gap: 1rem;
      z-index: 10;
    }

    .video-controls {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 1.5rem;
      background: linear-gradient(to top, rgba(0, 0, 0, 0.8), transparent);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .rep-counter {
      font-size: 3rem;
      font-weight: 700;
      color: white;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
    }

    .timer {
      font-size: 1.5rem;
      font-weight: 600;
      color: white;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
    }
    
    /* Camera flip button */
    #camera-flip {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 60px;
      height: 60px;
      background-color: var(--primary);
      color: white;
      border: none;
      border-radius: 50%;
      font-size: 1.8rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      transition: var(--transition);
      -webkit-tap-highlight-color: transparent;
    }
    
    #camera-flip:active {
      transform: scale(0.95);
      background-color: var(--secondary);
    }

    /* Charts */
    .chart-container {
      height: 300px;
      margin-bottom: 1rem;
    }

    /* Settings Panel */
    .settings-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 350px;
      height: 100vh;
      background-color: rgba(26, 26, 46, 0.95);
      border-left: 1px solid rgba(255, 255, 255, 0.1);
      padding: 2rem;
      z-index: 1000;
      transform: translateX(100%);
      transition: var(--transition);
      overflow-y: auto;
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
    }

    .settings-panel.open {
      transform: translateX(0);
    }

    .settings-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 2rem;
    }

    .settings-title {
      font-size: 1.5rem;
      font-weight: 600;
    }

    .close-settings {
      width: 2rem;
      height: 2rem;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: var(--transition);
    }

    .close-settings:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }

    .settings-section {
      margin-bottom: 2rem;
    }

    .settings-section-title {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 1rem;
      color: var(--light);
    }

    .form-group {
      margin-bottom: 1.5rem;
    }

    .form-label {
      display: block;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
      color: var(--gray);
    }

    .form-control {
      width: 100%;
      padding: 0.75rem 1rem;
      background-color: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      color: var(--light);
      font-family: inherit;
      font-size: 0.9rem;
      transition: var(--transition);
    }

    .form-control:focus {
      outline: none;
      border-color: var(--primary);
      background-color: rgba(255, 255, 255, 0.15);
    }

    .form-select {
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%236c757d' viewBox='0 0 16 16'%3E%3Cpath d='M7.247 11.14 2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 1rem center;
      background-size: 16px 12px;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(255, 255, 255, 0.2);
      transition: var(--transition);
      border-radius: 34px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: var(--transition);
      border-radius: 50%;
    }

    input:checked + .toggle-slider {
      background-color: var(--primary);
    }

    input:checked + .toggle-slider:before {
      transform: translateX(26px);
    }

    .toggle-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .toggle-text {
      font-size: 0.9rem;
    }

    .range-slider {
      width: 100%;
      margin-top: 0.5rem;
    }

    .range-slider input {
      width: 100%;
      -webkit-appearance: none;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.2);
      outline: none;
    }

    .range-slider input::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      transition: var(--transition);
    }

    .range-slider input::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      transition: var(--transition);
      border: none;
    }

    .range-slider input::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    .range-slider input::-moz-range-thumb:hover {
      transform: scale(1.2);
    }

    .range-values {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: var(--gray);
      margin-top: 0.5rem;
    }

    /* Workout History */
    .history-list {
      margin-top: 1rem;
    }

    .history-item {
      display: flex;
      align-items: center;
      padding: 1rem;
      border-radius: 12px;
      background-color: rgba(255, 255, 255, 0.05);
      margin-bottom: 1rem;
      transition: var(--transition);
    }

    .history-item:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }

    .history-icon {
      width: 3rem;
      height: 3rem;
      border-radius: 12px;
      background-color: rgba(67, 97, 238, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      color: var(--primary);
      margin-right: 1rem;
    }

    .history-details {
      flex: 1;
    }

    .history-title {
      font-weight: 600;
      margin-bottom: 0.25rem;
    }

    .history-meta {
      display: flex;
      gap: 1rem;
      font-size: 0.85rem;
      color: var(--gray);
    }

    .history-meta-item {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .history-actions {
      display: flex;
      gap: 0.5rem;
    }

    /* Loader */
    #loader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, var(--dark), #121224);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    
    .loader-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      max-width: 400px;
      padding: 2rem;
      background-color: rgba(26, 26, 46, 0.8);
      border-radius: 20px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      animation: fadeIn 0.5s ease forwards;
    }
    
    .loader-logo {
      display: flex;
      align-items: center;
      margin-bottom: 2rem;
      gap: 0.75rem;
    }
    
    .loader-logo .logo-icon {
      width: 3.5rem;
      height: 3.5rem;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      border-radius: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 1.5rem;
      box-shadow: 0 5px 15px rgba(67, 97, 238, 0.3);
      animation: logoEntrance 0.6s ease forwards;
    }
    
    .loader-logo .logo-text {
      font-size: 1.75rem;
      font-weight: 700;
      background: linear-gradient(to right, var(--primary), var(--accent));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: logoEntrance 0.6s 0.2s ease forwards;
      opacity: 0; /* Start hidden for animation */
    }

    .loader-spinner {
      width: 60px;
      height: 60px;
      border: 5px solid rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      border-top-color: var(--primary);
      border-left-color: var(--accent);
      animation: spin 1s ease-in-out infinite;
      margin-bottom: 1.5rem;
      box-shadow: 0 0 20px rgba(76, 201, 240, 0.3);
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes logoEntrance {
      0% { transform: scale(0.8); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loader-text {
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--light);
      margin-bottom: 1.5rem;
      text-align: center;
    }
    
    .loader-progress-container {
      width: 100%;
      height: 10px;
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      overflow: hidden;
      margin-bottom: 0.75rem;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
    }
    
    .loader-progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(to right, var(--primary), var(--accent));
      border-radius: 5px;
      transition: width 0.3s ease;
      box-shadow: 0 0 10px rgba(76, 201, 240, 0.5);
    }
    
    .loader-percentage {
      font-size: 1rem;
      font-weight: 600;
      color: var(--light);
      margin-bottom: 1.5rem;
    }
    
    .loader-message {
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.7);
      text-align: center;
      font-style: italic;
      animation: pulse 2s infinite ease-in-out;
    }
    
    @keyframes pulse {
      0% { opacity: 0.7; }
      50% { opacity: 1; }
      100% { opacity: 0.7; }
    }

    /* Responsive */
    @media (max-width: 992px) {
      .app-container {
        grid-template-columns: 1fr;
      }

      .sidebar {
        position: fixed;
        left: 0;
        top: 0;
        width: 280px;
        height: 100vh;
        z-index: 1000;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
        overflow-y: auto;
        box-shadow: 2px 0 10px rgba(0, 0, 0, 0.2);
      }

      .sidebar.open {
        transform: translateX(0);
      }
      
      /* Add overlay when sidebar is open */
      .sidebar.open::after {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: -1;
      }

      .main-content {
        padding: 1.5rem;
      }

      .dashboard-grid {
        grid-template-columns: 1fr;
      }
      
      /* Improved menu toggle button */
      .menu-toggle {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: var(--primary);
        color: white;
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1001;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 1.5rem;
      }
      
      .menu-toggle::before {
        content: '☰';
      }
      
      .menu-toggle.active {
        transform: rotate(90deg);
        background: var(--danger);
      }
    }

    @media (max-width: 576px) {
      .header {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem;
      }

      .action-buttons {
        width: 100%;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      
      .btn {
        padding: 0.6rem 1rem;
        font-size: 0.85rem;
        min-height: 44px; /* Apple's recommended minimum touch target size */
        min-width: 44px; /* Ensure minimum touch target width */
      }
      
      .btn-icon {
        width: 50px; /* Larger touch target for mobile */
        height: 50px; /* Larger touch target for mobile */
        font-size: 1.5rem;
      }

      .settings-panel {
        width: 100%;
        max-height: 80vh;
        overflow-y: auto;
        padding: 1rem;
      }
      
      .video-container {
        height: auto;
        max-height: 80vh;
        margin-bottom: 1rem;
      }
      
      .video-overlay {
        top: 1rem;
        right: 1rem;
        gap: 0.75rem;
      }
      
      .video-controls {
        padding: 1rem;
      }
      
      .rep-counter {
        font-size: 2.5rem;
      }
      
      .timer {
        font-size: 1.2rem;
      }
      
      .controls {
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.5rem;
      }
      
      /* Improve mobile menu visibility */
      .menu-toggle {
        width: 60px;
        height: 60px;
        font-size: 1.8rem;
        bottom: 30px;
        right: 30px;
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
      }
      
      .stat-value {
        font-size: 1.75rem;
      }
      
      .dashboard-grid .card {
        padding: 1rem;
      }
      
      canvas {
        max-width: 100%;
        height: auto;
      }
      
      /* Mobile-specific improvements */
      .form-control, select {
        font-size: 16px; /* Prevent iOS zoom on focus */
        height: 44px;
      }
      
      input[type="range"] {
        height: 44px;
      }
      
      .toggle-switch {
        min-height: 30px;
      }
      
      /* Prevent pull-to-refresh */
      html, body {
        overscroll-behavior-y: contain;
      }
      
      /* Camera flip button for mobile */
      .camera-flip-btn {
        position: absolute;
        bottom: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.5);
        color: white;
        border: none;
        border-radius: 50%;
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        z-index: 10;
      }
    }

    /* Focus Mode */
    .focus-mode .sidebar,
    .focus-mode .header,
    .focus-mode .dashboard-grid,
    .focus-mode .settings-panel {
      display: none;
    }

    .focus-mode .video-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      margin: 0;
      border-radius: 0;
    }

    .focus-mode #video-canvas {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .focus-mode .rep-counter {
      font-size: 6rem;
    }

    .focus-mode .timer {
      font-size: 2.5rem;
    }

    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideUp {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    .fade-in {
      animation: fadeIn 0.5s ease forwards;
    }

    .slide-up {
      animation: slideUp 0.5s ease forwards;
    }

    /* Version */
    .version {
      position: fixed;
      bottom: 10px;
      right: 10px;
      font-size: 0.75rem;
      color: rgba(255, 255, 255, 0.3);
      z-index: 10;
    }
  </style>
</head>
<body>
  <!-- Loader -->
  <div id="loader">
    <div class="loader-content">
      <div class="loader-logo">
        <div class="logo-icon">LC</div>
        <div class="logo-text">Lax Counter</div>
      </div>
      <div class="loader-spinner"></div>
      <div class="loader-text">Loading OpenCV.js...</div>
      <div class="loader-progress-container">
        <div class="loader-progress-bar" id="loader-progress"></div>
      </div>
      <div class="loader-percentage" id="loader-percentage">0%</div>
      <div class="loader-message">Preparing your workout experience</div>
      <button id="retry-loading" class="btn btn-primary" style="margin-top: 20px; display: none;">Retry Loading</button>
    </div>
  </div>

  <div class="app-container">
    <!-- Sidebar -->
    <div class="sidebar">
      <div class="logo">
        <div class="logo-icon">LC</div>
        <div class="logo-text">Lax Counter</div>
      </div>

      <div class="nav-section">
        <div class="nav-section-title">Main</div>
        <div class="nav-item active" data-page="dashboard">
          <div class="nav-icon">📊</div>
          <div>Dashboard</div>
        </div>
        <div class="nav-item" data-page="workout">
          <div class="nav-icon">🏋️</div>
          <div>Workout</div>
        </div>
        <div class="nav-item" data-page="history">
          <div class="nav-icon">📅</div>
          <div>History</div>
        </div>
        <div class="nav-item" data-page="stats">
          <div class="nav-icon">📈</div>
          <div>Statistics</div>
        </div>
      </div>

      <div class="nav-section">
        <div class="nav-section-title">Settings</div>
        <div class="nav-item" id="open-settings">
          <div class="nav-icon">⚙️</div>
          <div>Preferences</div>
        </div>
        <div class="nav-item">
          <div class="nav-icon">❓</div>
          <div>Help</div>
        </div>
      </div>

      <div class="user-profile">
        <div class="user-avatar">G</div>
        <div class="user-info">
          <div class="user-name">Guest User</div>
          <div class="user-status">Free Plan</div>
        </div>
      </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
      <div class="header">
        <div>
          <h1 class="page-title">Motion Rep Counter</h1>
          <p class="page-subtitle">Track your workout reps with precision</p>
        </div>
        <div class="action-buttons">
          <button class="btn btn-outline" id="toggle-focus-mode">
            <span class="btn-icon">👁️</span>
            <span>Focus Mode</span>
          </button>
          <button class="btn btn-primary" id="start-workout">
            <span class="btn-icon">▶️</span>
            <span>Start Workout</span>
          </button>
        </div>
      </div>

      <!-- Dashboard Grid -->
      <div class="dashboard-grid">
        <div class="card">
          <div class="card-header">
            <div class="card-title">Today's Reps</div>
            <div class="card-icon card-icon-primary">🏋️</div>
          </div>
          <div class="stat-value" id="today-reps">0</div>
          <div class="stat-label">Total repetitions</div>
          <div class="stat-change stat-change-positive">
            <span>↑</span>
            <span>12% from yesterday</span>
          </div>
        </div>

        <div class="card">
          <div class="card-header">
            <div class="card-title">Workout Time</div>
            <div class="card-icon card-icon-success">⏱️</div>
          </div>
          <div class="stat-value" id="workout-time">0:00</div>
          <div class="stat-label">Total time today</div>
          <div class="stat-change stat-change-positive">
            <span>↑</span>
            <span>5% from average</span>
          </div>
        </div>

        <div class="card">
          <div class="card-header">
            <div class="card-title">Weekly Goal</div>
            <div class="card-icon card-icon-warning">🎯</div>
          </div>
          <div class="stat-value" id="weekly-goal">45%</div>
          <div class="stat-label">Progress to goal</div>
          <div class="stat-change">
            <span>🔥</span>
            <span>On track for this week</span>
          </div>
        </div>
      </div>

      <!-- Video Container -->
      <div class="video-container">
        <canvas id="video-canvas"></canvas>
        <video id="video" autoplay playsinline muted></video>
        
        <div class="video-overlay">
          <button class="btn btn-outline btn-icon" id="toggle-detection">👁️</button>
          <button class="btn btn-danger btn-icon" id="reset-counter">🔄</button>
          <!-- Camera flip button (only visible on mobile) -->
          <button class="btn btn-primary btn-icon" id="camera-flip">📱</button>
        </div>
        
        <div class="video-controls">
          <div class="rep-counter" id="rep-counter">0 reps</div>
          <div class="timer" id="workout-timer">00:00</div>
        </div>
      </div>

      <!-- Charts -->
      <div class="card">
        <div class="card-header">
          <div class="card-title">Workout Progress</div>
        </div>
        <div class="chart-container">
          <canvas id="progress-chart"></canvas>
        </div>
      </div>
    </div>
  </div>

  <!-- Settings Panel -->
  <div class="settings-panel" id="settings-panel">
    <div class="settings-header">
      <div class="settings-title">Settings</div>
      <div class="close-settings" id="close-settings">✕</div>
    </div>

    <div class="settings-section">
      <div class="settings-section-title">Detection Settings</div>
      
      <div class="form-group">
        <label class="form-label">Detection Type</label>
        <select class="form-control form-select" id="detection-type">
          <option value="motion">Motion Detection</option>
          <option value="color">Color Tracking</option>
          <option value="pose">Pose Estimation</option>
        </select>
      </div>

      <div class="form-group">
        <label class="toggle-label">
          <span class="toggle-text">Show Detection Overlay</span>
          <label class="toggle-switch">
            <input type="checkbox" id="show-detection">
            <span class="toggle-slider"></span>
          </label>
        </label>
      </div>

      <div class="form-group">
        <label class="form-label">Detection Sensitivity</label>
        <div class="range-slider">
          <input type="range" min="1" max="10" value="5" id="sensitivity">
          <div class="range-values">
            <span>Low</span>
            <span>High</span>
          </div>
        </div>
      </div>

      <div class="form-group">
        <label class="form-label">Pause Between Reps (ms)</label>
        <input type="number" class="form-control" id="min-rep-duration" value="1000" min="300" max="5000" step="100">
        <div style="font-size: 0.8rem; color: var(--gray); margin-top: 0.5rem;">
          Controls both the minimum time between reps and the pause duration after each rep is counted.
        </div>
      </div>
    </div>

    <div class="settings-section">
      <div class="settings-section-title">Workout Goals</div>
      
      <div class="form-group">
        <label class="form-label">Daily Rep Goal</label>
        <input type="number" class="form-control" id="daily-goal" value="100">
      </div>

      <div class="form-group">
        <label class="form-label">Weekly Rep Goal</label>
        <input type="number" class="form-control" id="weekly-goal-input" value="500">
      </div>
    </div>

    <div class="settings-section">
      <div class="settings-section-title">App Settings</div>
      
      <div class="form-group">
        <label class="toggle-label">
          <span class="toggle-text">Sound Effects</span>
          <label class="toggle-switch">
            <input type="checkbox" id="sound-effects" checked>
            <span class="toggle-slider"></span>
          </label>
        </label>
      </div>

      <div class="form-group">
        <label class="toggle-label">
          <span class="toggle-text">Voice Announcements</span>
          <label class="toggle-switch">
            <input type="checkbox" id="voice-announcements">
            <span class="toggle-slider"></span>
          </label>
        </label>
      </div>

      <div class="form-group">
        <label class="toggle-label">
          <span class="toggle-text">Save Workout History</span>
          <label class="toggle-switch">
            <input type="checkbox" id="save-history" checked>
            <span class="toggle-slider"></span>
          </label>
        </label>
      </div>
    </div>

    <button class="btn btn-primary" style="width: 100%;">Save Settings</button>
  </div>

  <div class="version">v1.0.0</div>

  <!-- Audio Elements -->
  <audio id="rep-sound" src="https://actions.google.com/sounds/v1/sports/tennis_ball_hit_bounce.ogg" preload="auto"></audio>
  <audio id="milestone-sound" src="https://actions.google.com/sounds/v1/sports/crowd_cheer.ogg" preload="auto"></audio>

  <script>
    // DOM Elements
    const video = document.getElementById('video');
    const canvas = document.getElementById('video-canvas');
    const ctx = canvas.getContext('2d');
    const repCounter = document.getElementById('rep-counter');
    const workoutTimer = document.getElementById('workout-timer');
    const todayReps = document.getElementById('today-reps');
    const workoutTime = document.getElementById('workout-time');
    const weeklyGoal = document.getElementById('weekly-goal');
    const loader = document.getElementById('loader');
    const repSound = document.getElementById('rep-sound');
    const milestoneSound = document.getElementById('milestone-sound');
    const toggleDetectionBtn = document.getElementById('toggle-detection');
    const resetCounterBtn = document.getElementById('reset-counter');
    const startWorkoutBtn = document.getElementById('start-workout');
    const toggleFocusModeBtn = document.getElementById('toggle-focus-mode');
    const settingsPanel = document.getElementById('settings-panel');
    const openSettingsBtn = document.getElementById('open-settings');
    const closeSettingsBtn = document.getElementById('close-settings');
    const sidebar = document.querySelector('.sidebar');
    const menuToggle = document.querySelector('.menu-toggle');

    // State variables
    let reps = 0;
    let totalReps = 0;
    let workoutActive = false;
    let workoutStartTime = null;
    let timerInterval = null;
    let showDetection = false;
    let detectionType = 'motion';
    let sensitivity = 5;
    let minRepDuration = 300;
    let lastRepTime = 0;
    let repHistory = [];
    let workoutHistory = [];
    let focusMode = false;

    // Initialize charts
    function initCharts() {
      const ctx = document.getElementById('progress-chart').getContext('2d');
      
      // Sample data - would be replaced with actual user data
      const labels = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
      const data = {
        labels: labels,
        datasets: [{
          label: 'Daily Reps',
          data: [65, 78, 52, 91, 43, 56, 0],
          backgroundColor: 'rgba(67, 97, 238, 0.2)',
          borderColor: 'rgba(67, 97, 238, 1)',
          borderWidth: 2,
          tension: 0.3,
          fill: true
        }]
      };

      const config = {
        type: 'line',
        data: data,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: 'rgba(26, 26, 46, 0.9)',
              titleColor: '#fff',
              bodyColor: '#fff',
              borderColor: 'rgba(255, 255, 255, 0.1)',
              borderWidth: 1,
              padding: 10,
              displayColors: false,
              callbacks: {
                label: function(context) {
                  return `${context.parsed.y} reps`;
                }
              }
            }
          },
          scales: {
            x: {
              grid: {
                display: false,
                drawBorder: false
              },
              ticks: {
                color: 'rgba(255, 255, 255, 0.7)'
              }
            },
            y: {
              grid: {
                color: 'rgba(255, 255, 255, 0.1)',
                drawBorder: false
              },
              ticks: {
                color: 'rgba(255, 255, 255, 0.7)',
                padding: 10
              },
              beginAtZero: true
            }
          }
        }
      };

      new Chart(ctx, config);
    }

    // Enhanced Motion Detector Class
    class MotionDetector {
      constructor() {
        this.previousFrame = null;
        this.backgroundFrame = null;
        this.backgroundAlpha = 0.05; // Background adaptation rate
        this.motionThreshold = 30; // Default threshold
        this.minMotionPixels = 1000; // Minimum number of pixels that need to change
        this.motionState = 'idle'; // idle, moving, cooldown
        this.lastStateChange = 0;
        this.cooldownPeriod = 300; // ms
        this.consecutiveFrames = 0;
        this.requiredFrames = 3; // Number of consecutive frames needed to confirm motion
        this.motionHistory = []; // Store recent motion values for smoothing
        this.historySize = 5; // Number of frames to keep in history
        this.regionSize = 16; // Size of regions for regional motion detection
        this.regionThreshold = 0.6; // Percentage of region that must show motion
        this.motionRegions = []; // Track which regions have motion
        this.adaptiveThreshold = true; // Use adaptive thresholding
        this.noiseReduction = true; // Apply noise reduction
        this.frameSkip = 0; // Process every frame by default
        this.frameCount = 0;
      }

      setSensitivity(value) {
        // Scale 1-10 sensitivity to appropriate thresholds
        this.motionThreshold = 50 - (value * 4); // Higher sensitivity = lower threshold
        this.minMotionPixels = 2000 - (value * 150); // Higher sensitivity = fewer pixels needed
        this.requiredFrames = Math.max(2, 5 - Math.floor(value / 2)); // Higher sensitivity = fewer frames needed
        this.regionThreshold = 0.7 - (value * 0.03); // Higher sensitivity = lower region threshold
        this.backgroundAlpha = 0.01 + (value * 0.01); // Higher sensitivity = faster background adaptation
      }

      detect(context, videoElement) {
        // Draw current frame to canvas
        context.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
        
        // Skip frames if needed (for performance)
        this.frameCount++;
        if (this.frameSkip > 0 && (this.frameCount % (this.frameSkip + 1) !== 0)) {
          return false;
        }
        
        // Get current frame data
        const currentFrame = context.getImageData(0, 0, canvas.width, canvas.height);
        const currentData = currentFrame.data;
        
        // If we don't have a previous frame, store this one and return
        if (!this.previousFrame) {
          this.previousFrame = currentFrame;
          this.backgroundFrame = new ImageData(
            new Uint8ClampedArray(currentData), 
            currentFrame.width, 
            currentFrame.height
          );
          return false;
        }
        
        const previousData = this.previousFrame.data;
        const backgroundData = this.backgroundFrame.data;
        let motionPixels = 0;
        
        // Initialize or reset motion regions
        if (this.motionRegions.length === 0) {
          const regionsX = Math.ceil(canvas.width / this.regionSize);
          const regionsY = Math.ceil(canvas.height / this.regionSize);
          this.motionRegions = new Array(regionsX * regionsY).fill(0);
        } else {
          this.motionRegions.fill(0);
        }
        
        // Compare frames to detect motion with regional analysis
        for (let y = 0; y < canvas.height; y++) {
          for (let x = 0; x < canvas.width; x++) {
            const i = (y * canvas.width + x) * 4;
            
            // Calculate region index
            const regionX = Math.floor(x / this.regionSize);
            const regionY = Math.floor(y / this.regionSize);
            const regionIdx = regionY * Math.ceil(canvas.width / this.regionSize) + regionX;
            
            // Calculate pixel brightness (simple grayscale conversion)
            const currentBrightness = (currentData[i] * 0.299 + currentData[i+1] * 0.587 + currentData[i+2] * 0.114) / 255;
            const prevBrightness = (previousData[i] * 0.299 + previousData[i+1] * 0.587 + previousData[i+2] * 0.114) / 255;
            const bgBrightness = (backgroundData[i] * 0.299 + backgroundData[i+1] * 0.587 + backgroundData[i+2] * 0.114) / 255;
            
            // Calculate difference from both previous frame and background model
            const frameDiff = Math.abs(currentBrightness - prevBrightness);
            const bgDiff = Math.abs(currentBrightness - bgBrightness);
            
            // Determine threshold (fixed or adaptive)
            let threshold = this.motionThreshold / 255; // Convert to 0-1 range
            if (this.adaptiveThreshold) {
              // Make threshold adaptive based on local brightness
              threshold *= (0.5 + currentBrightness * 0.5); // Brighter areas need more change
            }
            
            // Detect motion using both frame difference and background difference
            if (frameDiff > threshold && bgDiff > threshold * 0.5) {
              // Count as motion pixel
              motionPixels++;
              this.motionRegions[regionIdx]++;
              
              // Update background model (slower for moving pixels)
              backgroundData[i] = backgroundData[i] * (1 - this.backgroundAlpha * 0.2) + currentData[i] * (this.backgroundAlpha * 0.2);
              backgroundData[i+1] = backgroundData[i+1] * (1 - this.backgroundAlpha * 0.2) + currentData[i+1] * (this.backgroundAlpha * 0.2);
              backgroundData[i+2] = backgroundData[i+2] * (1 - this.backgroundAlpha * 0.2) + currentData[i+2] * (this.backgroundAlpha * 0.2);
              
              // Optionally highlight motion pixels if detection overlay is enabled
              if (showDetection) {
                // Draw a small semi-transparent rectangle at motion point
                context.fillStyle = 'rgba(76, 201, 240, 0.5)';
                context.fillRect(x, y, 2, 2);
              }
            } else {
              // Update background model (faster for static pixels)
              backgroundData[i] = backgroundData[i] * (1 - this.backgroundAlpha) + currentData[i] * this.backgroundAlpha;
              backgroundData[i+1] = backgroundData[i+1] * (1 - this.backgroundAlpha) + currentData[i+1] * this.backgroundAlpha;
              backgroundData[i+2] = backgroundData[i+2] * (1 - this.backgroundAlpha) + currentData[i+2] * this.backgroundAlpha;
            }
          }
        }
        
        // Count regions with significant motion
        let activeRegions = 0;
        const pixelsPerRegion = this.regionSize * this.regionSize;
        
        for (let i = 0; i < this.motionRegions.length; i++) {
          if (this.motionRegions[i] > pixelsPerRegion * this.regionThreshold) {
            activeRegions++;
            
            // Visualize active regions if detection overlay is enabled
            if (showDetection) {
              const regionsPerRow = Math.ceil(canvas.width / this.regionSize);
              const regionY = Math.floor(i / regionsPerRow);
              const regionX = i % regionsPerRow;
              
              context.strokeStyle = 'rgba(231, 29, 54, 0.7)';
              context.lineWidth = 2;
              context.strokeRect(
                regionX * this.regionSize, 
                regionY * this.regionSize, 
                this.regionSize, 
                this.regionSize
              );
            }
          }
        }
        
        // Add current motion value to history for smoothing
        this.motionHistory.push(motionPixels);
        if (this.motionHistory.length > this.historySize) {
          this.motionHistory.shift();
        }
        
        // Calculate smoothed motion value
        const smoothedMotion = this.motionHistory.reduce((sum, val) => sum + val, 0) / this.motionHistory.length;
        
        // Store current frame as previous for next comparison
        this.previousFrame = currentFrame;
        
        const now = Date.now();
        let repDetected = false;
        
        // State machine for rep detection using smoothed motion and active regions
        const motionDetected = smoothedMotion > this.minMotionPixels || activeRegions > (this.motionRegions.length * 0.1);
        
        if (motionDetected) {
          // Motion detected
          if (this.motionState === 'idle') {
            this.consecutiveFrames++;
            
            if (this.consecutiveFrames >= this.requiredFrames) {
              this.motionState = 'moving';
              this.lastStateChange = now;
              this.consecutiveFrames = 0;
            }
          }
        } else {
          // No motion detected
          this.consecutiveFrames = 0;
          
          if (this.motionState === 'moving' && (now - this.lastStateChange) > minRepDuration) {
            this.motionState = 'cooldown';
            this.lastStateChange = now;
            repDetected = true;
          } else if (this.motionState === 'cooldown' && (now - this.lastStateChange) > this.cooldownPeriod) {
            this.motionState = 'idle';
          }
        }
        
        // Draw motion state indicator and debug information if detection overlay is enabled
        if (showDetection) {
          // Draw state indicator
          const stateColors = {
            'idle': 'rgba(46, 196, 182, 0.8)',
            'moving': 'rgba(231, 29, 54, 0.8)',
            'cooldown': 'rgba(255, 159, 28, 0.8)'
          };
          
          context.fillStyle = stateColors[this.motionState];
          context.fillRect(10, 10, 30, 30);
          
          // Draw motion level bar
          const barWidth = 150;
          const barHeight = 15;
          const barX = 50;
          const barY = 18;
          const motionPercentage = Math.min(1, smoothedMotion / (this.minMotionPixels * 1.5));
          
          // Background bar
          context.fillStyle = 'rgba(255, 255, 255, 0.2)';
          context.fillRect(barX, barY, barWidth, barHeight);
          
          // Motion level bar
          context.fillStyle = motionPercentage > 0.8 ? 'rgba(231, 29, 54, 0.8)' : 
                             motionPercentage > 0.4 ? 'rgba(255, 159, 28, 0.8)' : 
                             'rgba(46, 196, 182, 0.8)';
          context.fillRect(barX, barY, barWidth * motionPercentage, barHeight);
          
          // Threshold marker
          const thresholdPosition = barX + (barWidth * (this.minMotionPixels / (this.minMotionPixels * 1.5)));
          context.fillStyle = 'rgba(255, 255, 255, 0.8)';
          context.fillRect(thresholdPosition - 1, barY - 5, 2, barHeight + 10);
          
          // Add text labels
          context.font = '16px Montserrat';
          context.fillStyle = 'white';
          context.fillText(`State: ${this.motionState}`, 50, 50);
          context.fillText(`Motion: ${Math.round(smoothedMotion)}`, 50, 75);
          context.fillText(`Regions: ${activeRegions}/${this.motionRegions.length}`, 50, 100);
          context.fillText(`Threshold: ${this.minMotionPixels}`, 50, 125);
          
          // Draw frame processing info
          if (this.frameSkip > 0) {
            context.fillText(`Processing: 1/${this.frameSkip + 1} frames`, 50, 150);
          }
        }
        
        return repDetected;
      }
    }

    // Color Tracker Class
    class ColorTracker {
      constructor() {
        this.targetHue = 0; // Default to red
        this.hueRange = 20;
        this.minSaturation = 50;
        this.minValue = 50;
        this.minContourArea = 1000;
        this.trackedObject = { x: 0, y: 0, width: 0, height: 0, area: 0 };
        this.previousY = null;
        this.movementThreshold = 20;
        this.movementState = 'idle'; // idle, up, down
        this.lastStateChange = 0;
      }

      setSensitivity(value) {
        this.hueRange = 10 + value;
        this.minContourArea = 2000 - (value * 150);
        this.movementThreshold = 30 - (value * 2);
      }

      detect(context, videoElement) {
        if (typeof cv === 'undefined') return false;

        let src = new cv.Mat(videoElement.height, videoElement.width, cv.CV_8UC4);
        let hsv = new cv.Mat();
        let mask = new cv.Mat();
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();

        // Draw current frame to canvas
        context.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
        
        // Get frame data for OpenCV processing
        src.data.set(context.getImageData(0, 0, canvas.width, canvas.height).data);
        
        // Convert to HSV color space
        cv.cvtColor(src, hsv, cv.COLOR_RGBA2RGB);
        cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);
        
        // Define range for target color in HSV
        let lowerBound = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), 
          [Math.max(0, this.targetHue - this.hueRange), this.minSaturation, this.minValue, 0]);
        let upperBound = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), 
          [Math.min(180, this.targetHue + this.hueRange), 255, 255, 255]);
        
        // Threshold the HSV image to get only target colors
        cv.inRange(hsv, lowerBound, upperBound, mask);
        
        // Find contours
        cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
        
        // Find the largest contour
        let maxArea = 0;
        let maxContourIndex = -1;
        
        for (let i = 0; i < contours.size(); ++i) {
          let contour = contours.get(i);
          let area = cv.contourArea(contour);
          
          if (area > maxArea && area > this.minContourArea) {
            maxArea = area;
            maxContourIndex = i;
          }
        }
        
        let repDetected = false;
        const now = Date.now();
        
        // If we found a valid contour
        if (maxContourIndex !== -1) {
          let contour = contours.get(maxContourIndex);
          let rect = cv.boundingRect(contour);
          
          this.trackedObject = {
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height,
            area: maxArea,
            centerY: rect.y + (rect.height / 2)
          };
          
          // Draw rectangle around the tracked object if detection overlay is enabled
          if (showDetection) {
            context.strokeStyle = '#4cc9f0';
            context.lineWidth = 2;
            context.strokeRect(rect.x, rect.y, rect.width, rect.height);
            
            // Draw center point
            context.fillStyle = '#e71d36';
            context.beginPath();
            context.arc(rect.x + (rect.width / 2), rect.y + (rect.height / 2), 5, 0, 2 * Math.PI);
            context.fill();
          }
          
          // Track vertical movement for rep counting
          if (this.previousY !== null) {
            const deltaY = this.trackedObject.centerY - this.previousY;
            
            // State machine for rep detection
            if (deltaY < -this.movementThreshold && this.movementState !== 'up') {
              // Moving up
              this.movementState = 'up';
              this.lastStateChange = now;
            } else if (deltaY > this.movementThreshold && this.movementState === 'up' && 
                      (now - this.lastStateChange) > minRepDuration) {
              // Moving down after being up
              this.movementState = 'down';
              this.lastStateChange = now;
              repDetected = true;
            } else if (Math.abs(deltaY) < this.movementThreshold && this.movementState === 'down' && 
                      (now - this.lastStateChange) > 300) {
              // Back to idle
              this.movementState = 'idle';
            }
          }
          
          this.previousY = this.trackedObject.centerY;
        } else {
          this.previousY = null;
        }
        
        // Draw movement state indicator if detection overlay is enabled
        if (showDetection) {
          context.fillStyle = this.movementState === 'idle' ? 'rgba(46, 196, 182, 0.5)' : 
                             this.movementState === 'up' ? 'rgba(231, 29, 54, 0.5)' : 
                             'rgba(255, 159, 28, 0.5)';
          context.fillRect(10, 10, 20, 20);
          
          // Add text label
          context.font = '16px Montserrat';
          context.fillStyle = 'white';
          context.fillText(`State: ${this.movementState}`, 40, 25);
          if (this.previousY !== null) {
            context.fillText(`Y-Pos: ${Math.round(this.trackedObject.centerY)}`, 40, 50);
          }
        }
        
        // Clean up OpenCV resources
        src.delete();
        hsv.delete();
        mask.delete();
        contours.delete();
        hierarchy.delete();
        lowerBound.delete();
        upperBound.delete();
        
        return repDetected;
      }
    }

    // PoseDetector Class for hand and arm tracking
    class PoseDetector {
      constructor() {
        this.previousHandY = null;
        this.lowestHandY = null;
        this.highestHandY = null;
        this.rangeOfMotionThreshold = 0.65; // 65% range of motion required for a rep
        this.movementState = 'idle'; // idle, up, down
        this.lastStateChange = 0;
        this.movementThreshold = 10;
        this.shoulderX = 0;
        this.shoulderY = 0;
        this.armX = 0;
        this.armY = 0;
        this.handX = 0;
        this.handY = 0;
        this.calibrated = false;
        this.handDetected = false;
        this.armDetected = false;
        this.movementHistory = []; // Store recent movement values for smoothing
        this.historySize = 5; // Number of frames to keep in history
      }

      setSensitivity(value) {
        // Adjust sensitivity parameters
        this.movementThreshold = 15 - (value * 1); // Higher sensitivity = lower threshold
        this.rangeOfMotionThreshold = Math.max(0.5, 0.8 - (value * 0.03)); // Higher sensitivity = lower ROM requirement
      }

      detect(context, videoElement) {
        if (typeof cv === 'undefined') return false;

        // Draw current frame to canvas
        context.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
        
        // Hand and arm tracking with color detection
        let src = new cv.Mat(videoElement.height, videoElement.width, cv.CV_8UC4);
        let hsv = new cv.Mat();
        let mask = new cv.Mat();
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        
        // Get frame data for OpenCV processing
        src.data.set(context.getImageData(0, 0, canvas.width, canvas.height).data);
        
        // Convert to HSV color space for better color detection
        cv.cvtColor(src, hsv, cv.COLOR_RGBA2RGB);
        cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);
        
        // Define range for skin color in HSV (improved for hand detection)
        let lowerBound = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [0, 20, 70, 0]);
        let upperBound = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [25, 170, 255, 255]);
        
        // Threshold the HSV image to get only skin colors
        cv.inRange(hsv, lowerBound, upperBound, mask);
        
        // Apply morphological operations to improve hand detection
        let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
        cv.morphologyEx(mask, mask, cv.MORPH_OPEN, kernel);
        cv.morphologyEx(mask, mask, cv.MORPH_CLOSE, kernel);
        kernel.delete();
        
        // Find contours
        cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
        
        // Find contours that could be hand, arm, or shoulder
        let areas = [];
        for (let i = 0; i < contours.size(); ++i) {
          let contour = contours.get(i);
          let area = cv.contourArea(contour);
          if (area > 300) { // Lower threshold to detect smaller hand regions
            areas.push({index: i, area: area});
          }
        }
        
        // Sort by area (descending)
        areas.sort((a, b) => b.area - a.area);
        
        let repDetected = false;
        const now = Date.now();
        
        // Reset detection flags
        this.handDetected = false;
        this.armDetected = false;
        
        // If we found at least one contour
        if (areas.length > 0) {
          // Process the contours to identify hand, arm, and shoulder
          // We'll use position and size heuristics to identify body parts
          
          // First, find the largest contour (likely the main body/shoulder area)
          let shoulderContour = contours.get(areas[0].index);
          let shoulderRect = cv.boundingRect(shoulderContour);
          
          this.shoulderX = shoulderRect.x + (shoulderRect.width / 2);
          this.shoulderY = shoulderRect.y + (shoulderRect.height / 2);
          
          // Look for smaller contours that could be the arm or hand
          // We'll use the top 3 contours if available
          let potentialParts = Math.min(areas.length, 3);
          
          for (let i = 0; i < potentialParts; i++) {
            let contour = contours.get(areas[i].index);
            let rect = cv.boundingRect(contour);
            let centerX = rect.x + (rect.width / 2);
            let centerY = rect.y + (rect.height / 2);
            
            // Use heuristics to identify parts
            // Hand is typically smaller and can be at the extremity
            if (!this.handDetected && rect.width < shoulderRect.width * 0.7 && rect.height < shoulderRect.height * 0.7) {
              this.handX = centerX;
              this.handY = centerY;
              this.handDetected = true;
              
              // Draw hand point if detection overlay is enabled
              if (showDetection) {
                context.fillStyle = '#e71d36';
                context.beginPath();
                context.arc(this.handX, this.handY, 8, 0, 2 * Math.PI);
                context.fill();
                context.fillText('Hand', this.handX + 15, this.handY);
              }
            }
            // Arm is typically medium-sized and between shoulder and hand
            else if (!this.armDetected && rect.width < shoulderRect.width * 0.9) {
              this.armX = centerX;
              this.armY = centerY;
              this.armDetected = true;
              
              // Draw arm point if detection overlay is enabled
              if (showDetection) {
                context.fillStyle = '#4cc9f0';
                context.beginPath();
                context.arc(this.armX, this.armY, 8, 0, 2 * Math.PI);
                context.fill();
                context.fillText('Arm', this.armX + 15, this.armY);
              }
            }
          }
          
          // If we couldn't detect a separate hand, use the arm position as a fallback
          if (!this.handDetected && this.armDetected) {
            this.handX = this.armX;
            this.handY = this.armY;
            this.handDetected = true;
          }
          
          // Draw additional tracking elements if detection overlay is enabled
          if (showDetection) {
            // Draw shoulder point
            context.fillStyle = '#4cc9f0';
            context.beginPath();
            context.arc(this.shoulderX, this.shoulderY, 8, 0, 2 * Math.PI);
            context.fill();
            context.fillText('Shoulder', this.shoulderX + 15, this.shoulderY);
            
            // Draw connecting lines between detected body parts
            if (this.armDetected && this.handDetected) {
              // Draw line connecting shoulder, arm, and hand
              context.strokeStyle = '#ffffff';
              context.lineWidth = 2;
              context.beginPath();
              context.moveTo(this.shoulderX, this.shoulderY);
              if (this.armX !== this.handX || this.armY !== this.handY) {
                context.lineTo(this.armX, this.armY);
              }
              context.lineTo(this.handX, this.handY);
              context.stroke();
            } else if (this.armDetected) {
              // Draw line connecting shoulder and arm
              context.strokeStyle = '#ffffff';
              context.lineWidth = 2;
              context.beginPath();
              context.moveTo(this.shoulderX, this.shoulderY);
              context.lineTo(this.armX, this.armY);
              context.stroke();
            } else if (this.handDetected) {
              // Draw line connecting shoulder and hand
              context.strokeStyle = '#ffffff';
              context.lineWidth = 2;
              context.beginPath();
              context.moveTo(this.shoulderX, this.shoulderY);
              context.lineTo(this.handX, this.handY);
              context.stroke();
            }
          }
          
          // Track vertical movement of hand for rep counting
          if (this.handDetected && this.previousHandY !== null) {
            // Add current hand position to movement history for smoothing
            this.movementHistory.push(this.handY);
            if (this.movementHistory.length > this.historySize) {
              this.movementHistory.shift();
            }
            
            // Calculate smoothed hand position
            const smoothedHandY = this.movementHistory.reduce((sum, val) => sum + val, 0) / this.movementHistory.length;
            
            // Initialize calibration values if not set
            if (!this.calibrated) {
              this.lowestHandY = smoothedHandY;
              this.highestHandY = smoothedHandY;
              this.calibrated = true;
            }
            
            // Update range of motion boundaries with some dampening to avoid jitter
            if (smoothedHandY < this.highestHandY - 5) {
              this.highestHandY = smoothedHandY; // Higher position (lower Y value)
            }
            if (smoothedHandY > this.lowestHandY + 5) {
              this.lowestHandY = smoothedHandY; // Lower position (higher Y value)
            }
            
            // Calculate total range of motion
            const totalRange = this.lowestHandY - this.highestHandY;
            
            // Calculate current position as percentage of range
            let currentPosition = 0;
            if (totalRange > 0) {
              currentPosition = (this.lowestHandY - smoothedHandY) / totalRange;
            }
            
            // State machine for rep detection with range of motion threshold
            const deltaY = smoothedHandY - this.previousHandY;
            
            if (deltaY < -this.movementThreshold && this.movementState !== 'up') {
              // Moving up
              this.movementState = 'up';
              this.lastStateChange = now;
            } else if (deltaY > this.movementThreshold && this.movementState === 'up' && 
                      (now - this.lastStateChange) > minRepDuration) {
              // Moving down after being up
              // Only count as rep if range of motion threshold was met
              if (currentPosition >= this.rangeOfMotionThreshold) {
                this.movementState = 'down';
                this.lastStateChange = now;
                repDetected = true;
              }
            } else if (Math.abs(deltaY) < this.movementThreshold && this.movementState === 'down' && 
                      (now - this.lastStateChange) > 300) {
              // Back to idle
              this.movementState = 'idle';
            }
            
            // Update previous hand position for next frame
            this.previousHandY = smoothedHandY;
            
            // Draw ROM indicator if detection overlay is enabled
            if (showDetection) {
              // Draw movement state
              context.font = '16px Montserrat';
              context.fillStyle = 'white';
              context.fillText(`State: ${this.movementState}`, 40, 50);
              context.fillText(`Hand Y: ${Math.round(smoothedHandY)}`, 40, 75);
              context.fillText(`ROM: ${Math.round(currentPosition * 100)}%`, 40, 100);
              context.fillText(`Threshold: ${Math.round(this.rangeOfMotionThreshold * 100)}%`, 40, 125);
              
              // Draw ROM bar
              const barWidth = 150;
              const barHeight = 15;
              const barX = 40;
              const barY = 135;
              
              // Background bar
              context.fillStyle = 'rgba(255, 255, 255, 0.2)';
              context.fillRect(barX, barY, barWidth, barHeight);
              
              // Current ROM bar
              context.fillStyle = currentPosition >= this.rangeOfMotionThreshold ? 
                                'rgba(46, 196, 182, 0.8)' : 'rgba(231, 29, 54, 0.8)';
              context.fillRect(barX, barY, barWidth * currentPosition, barHeight);
              
              // Draw threshold marker
              context.fillStyle = 'rgba(255, 255, 255, 0.8)';
              context.fillRect(barX + (barWidth * this.rangeOfMotionThreshold) - 1, barY - 5, 2, barHeight + 10);
            }
          } else if (this.handDetected) {
            // First detection of hand, initialize tracking
            this.previousHandY = this.handY;
            this.movementHistory = Array(this.historySize).fill(this.handY);
          }
              
            }
          }
        } else {
          // No contours detected, reset tracking
          this.previousHandY = null;
          this.handDetected = false;
          this.armDetected = false;
        }
        
        // Draw movement state indicator if detection overlay is enabled
        if (showDetection) {
          context.fillStyle = this.movementState === 'idle' ? 'rgba(46, 196, 182, 0.5)' : 
                             this.movementState === 'up' ? 'rgba(231, 29, 54, 0.5)' : 
                             'rgba(255, 159, 28, 0.5)';
          context.fillRect(10, 10, 20, 20);
          
          // Add text label
          context.font = '16px Montserrat';
          context.fillStyle = 'white';
          context.fillText(`State: ${this.movementState}`, 40, 25);
          if (this.handDetected) {
            context.fillText(`Hand Y: ${Math.round(this.handY)}`, 150, 25);
          }
        }
        
        // Clean up OpenCV resources
        src.delete();
        hsv.delete();
        mask.delete();
        contours.delete();
        hierarchy.delete();
        lowerBound.delete();
        upperBound.delete();
        
        return repDetected;
      }
    }

    // Initialize detectors
    const motionDetector = new MotionDetector();
    const colorTracker = new ColorTracker();
    const poseDetector = new PoseDetector();
    let activeDetector = motionDetector;

    // Setup camera with mobile optimizations
    async function setupCamera() {
      try {
        // Check if this is a mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isAndroid = /Android/i.test(navigator.userAgent);
        
        console.log('Device detection:', { isMobile, isIOS, isAndroid, userAgent: navigator.userAgent });
        
        // Adjust constraints based on device type
        const constraints = {
          audio: false,
          video: {
            width: { ideal: isMobile ? 640 : 1280 },
            height: { ideal: isMobile ? 480 : 720 },
            facingMode: 'user'
          }
        };
        
        // iOS-specific adjustments
        if (isIOS) {
          // iOS sometimes works better with more flexible constraints
          constraints.video.width = { min: 320, ideal: 640, max: 1280 };
          constraints.video.height = { min: 240, ideal: 480, max: 720 };
          
          // Ensure video element is properly sized and visible
          video.style.width = '100%';
          video.style.height = 'auto';
          video.style.objectFit = 'contain';
          video.setAttribute('playsinline', true); // Critical for iOS inline video
          video.setAttribute('autoplay', true);
          video.setAttribute('muted', true);
        }
        
        // For mobile devices, especially iOS, we need to handle orientation changes
        const handleOrientationChange = () => {
          console.log('Orientation/resize event detected');
          setTimeout(() => {
            if (video.videoWidth > 0) {
              canvas.width = video.videoWidth;
              canvas.height = video.videoHeight;
              console.log('Canvas resized to:', { width: canvas.width, height: canvas.height });
              
              // Force redraw of UI elements
              if (isIOS) {
                // This can help with iOS rendering issues
                video.style.display = 'none';
                setTimeout(() => { video.style.display = 'block'; }, 50);
              }
            } else {
              console.warn('Video dimensions not available during resize');
            }
          }, 800); // Increased delay to allow video dimensions to update on iOS
        };
        
        window.addEventListener('orientationchange', handleOrientationChange);
        window.addEventListener('resize', handleOrientationChange);
        
        // Get camera stream
        console.log('Requesting camera with constraints:', constraints);
        let stream;
        
        try {
          stream = await navigator.mediaDevices.getUserMedia(constraints);
          console.log('Camera access granted with primary constraints');
        } catch (err) {
          console.warn('Failed with primary constraints:', err);
          
          // Fallback to simpler constraints
          console.log('Trying fallback constraints...');
          const fallbackConstraints = { video: true, audio: false };
          stream = await navigator.mediaDevices.getUserMedia(fallbackConstraints);
          console.log('Camera access granted with fallback constraints');
        }
        
        video.srcObject = stream;
        
        return new Promise((resolve) => {
          video.onloadedmetadata = () => {
            console.log('Video metadata loaded:', { width: video.videoWidth, height: video.videoHeight });
            // Set canvas dimensions to match video
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            // Use the existing camera flip button for mobile devices
            const cameraFlipBtn = document.getElementById('camera-flip');
            if (isMobile && cameraFlipBtn) {
              // Show the camera flip button
              cameraFlipBtn.style.display = 'flex';
              cameraFlipBtn.title = 'Switch Camera';
              
              // Set initial icon based on current camera
              cameraFlipBtn.innerHTML = constraints.video.facingMode === 'user' ? '📱' : '🤳';
              
              console.log('Camera flip button enabled for mobile device');
              
              // Add click event listener
              cameraFlipBtn.addEventListener('click', async () => {
                // Toggle between front and back camera
                const currentFacingMode = constraints.video.facingMode;
                constraints.video.facingMode = currentFacingMode === 'user' ? 'environment' : 'user';
                
                // Update button icon
                cameraFlipBtn.innerHTML = constraints.video.facingMode === 'user' ? '📱' : '🤳';
                
                // Stop current stream
                stream.getTracks().forEach(track => track.stop());
                
                try {
                  // Get new stream with updated constraints
                  const newStream = await navigator.mediaDevices.getUserMedia(constraints);
                  video.srcObject = newStream;
                  
                  // Update canvas dimensions after camera switch
                  setTimeout(() => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                  }, 300);
                } catch (err) {
                  console.error('Error flipping camera:', err);
                  alert('Unable to flip camera. Your device may not support this feature.');
                  // Revert to previous camera
                  constraints.video.facingMode = currentFacingMode;
                  cameraFlipBtn.innerHTML = constraints.video.facingMode === 'user' ? '📱' : '🤳';
                  const revertStream = await navigator.mediaDevices.getUserMedia(constraints);
                  video.srcObject = revertStream;
                }
              });
            }
            
            resolve();
          };
        });
      } catch (error) {
        console.error('Error accessing camera:', error);
        alert('Error accessing camera. Please make sure you have granted camera permissions and are using a supported browser.');
      }
    }

    // Main detection loop
    function detectionLoop() {
      if (!video.paused && !video.ended) {
        const now = Date.now();
        
        // Check if we're in a pause period after a rep
        if (inRepPause) {
          // If the pause period is over, exit the pause state
          if (now >= repPauseEndTime) {
            inRepPause = false;
            
            // Optional: Show visual indicator that next rep can be counted
            if (showDetection) {
              ctx.fillStyle = 'rgba(46, 196, 182, 0.5)';
              ctx.fillRect(canvas.width - 30, 10, 20, 20);
              ctx.font = '16px Montserrat';
              ctx.fillStyle = 'white';
              ctx.fillText('Ready', canvas.width - 90, 25);
            }
          } else {
            // Still in pause period, show countdown
            if (showDetection) {
              const remainingPause = Math.ceil((repPauseEndTime - now) / 1000);
              ctx.fillStyle = 'rgba(255, 159, 28, 0.5)';
              ctx.fillRect(canvas.width - 30, 10, 20, 20);
              ctx.font = '16px Montserrat';
              ctx.fillStyle = 'white';
              ctx.fillText(`Pause: ${remainingPause}s`, canvas.width - 120, 25);
            }
          }
          
          // Still detect motion but don't count reps during pause
          activeDetector.detect(ctx, video);
        } else {
          // Not in pause period, detect motion and check for reps
          const repDetected = activeDetector.detect(ctx, video);
          
          if (repDetected && workoutActive && (now - lastRepTime) > minRepDuration) {
            // Increment rep counter
            reps++;
            totalReps++;
            lastRepTime = now;
            
            // Enter pause state
            inRepPause = true;
            repPauseEndTime = now + minRepDuration; // Use minRepDuration as pause duration
            
            // Update UI
            repCounter.textContent = `${reps} reps`;
            todayReps.textContent = totalReps;
            
            // Play sound
            if (document.getElementById('sound-effects').checked) {
              repSound.play().catch(e => console.log('Audio play error:', e));
            }
            
            // Check for milestones
            if (reps % 10 === 0) {
              if (document.getElementById('sound-effects').checked) {
                milestoneSound.play().catch(e => console.log('Audio play error:', e));
              }
              
              // Voice announcement
              if (document.getElementById('voice-announcements').checked) {
                announceReps(reps);
              }
            }
            
            // Record rep timestamp
            repHistory.push({
              timestamp: now,
              workout: workoutStartTime
            });
          }
        }
      }
      
      requestAnimationFrame(detectionLoop);
    }

    // Voice announcements
    function announceReps(count) {
      if ('speechSynthesis' in window) {
        const announcement = new SpeechSynthesisUtterance(`${count} repetitions completed`);
        window.speechSynthesis.speak(announcement);
      }
    }

    // Timer functions
    function startTimer() {
      if (timerInterval) clearInterval(timerInterval);
      
      timerInterval = setInterval(() => {
        if (!workoutActive) return;
        
        const elapsed = Math.floor((Date.now() - workoutStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        
        workoutTimer.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        workoutTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
      }, 1000);
    }

    function resetTimer() {
      workoutTimer.textContent = '00:00';
      workoutTime.textContent = '0:00';
    }

    // Event listeners
    function setupEventListeners() {
      // Toggle detection overlay
      toggleDetectionBtn.addEventListener('click', () => {
        showDetection = !showDetection;
        toggleDetectionBtn.innerHTML = showDetection ? '👁️‍🗨️' : '👁️';
      });
      
      // Reset counter
      resetCounterBtn.addEventListener('click', () => {
        reps = 0;
        repCounter.textContent = '0 reps';
      });
      
      // Start/stop workout
      startWorkoutBtn.addEventListener('click', () => {
        if (workoutActive) {
          // Stop workout
          workoutActive = false;
          startWorkoutBtn.innerHTML = '<span class="btn-icon">▶️</span><span>Start Workout</span>';
          
          // Save workout to history if enabled
          if (document.getElementById('save-history').checked && reps > 0) {
            const workout = {
              id: Date.now(),
              date: new Date(),
              duration: Math.floor((Date.now() - workoutStartTime) / 1000),
              reps: reps,
              type: detectionType
            };
            
            workoutHistory.push(workout);
            saveToLocalStorage();
          }
        } else {
          // Start workout
          workoutActive = true;
          workoutStartTime = Date.now();
          startWorkoutBtn.innerHTML = '<span class="btn-icon">⏹️</span><span>End Workout</span>';
          reps = 0;
          repCounter.textContent = '0 reps';
          resetTimer();
          startTimer();
        }
      });
      
      // Toggle focus mode
      toggleFocusModeBtn.addEventListener('click', () => {
        document.body.classList.toggle('focus-mode');
        focusMode = document.body.classList.contains('focus-mode');
      });
      
      // Settings panel with mobile improvements
      openSettingsBtn.addEventListener('click', () => {
        settingsPanel.classList.add('open');
        
        // On mobile, scroll to settings panel when opened
        if (window.innerWidth <= 576) {
          setTimeout(() => {
            settingsPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }, 100);
        }
      });
      
      closeSettingsBtn.addEventListener('click', () => {
        settingsPanel.classList.remove('open');
      });
      
      // Add swipe gesture support for mobile devices
      let touchStartX = 0;
      let touchEndX = 0;
      
      document.addEventListener('touchstart', e => {
        touchStartX = e.changedTouches[0].screenX;
      }, false);
      
      document.addEventListener('touchend', e => {
        touchEndX = e.changedTouches[0].screenX;
        handleSwipe();
      }, false);
      
      function handleSwipe() {
        const swipeThreshold = 100; // Minimum distance for swipe
        
        // Right to left swipe (open settings)
        if (touchEndX < touchStartX - swipeThreshold) {
          if (!settingsPanel.classList.contains('open')) {
            settingsPanel.classList.add('open');
            
            // On mobile, scroll to settings panel when opened
            if (window.innerWidth <= 576) {
              setTimeout(() => {
                settingsPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
              }, 100);
            }
          }
        }
        
        // Left to right swipe (close settings)
        if (touchEndX > touchStartX + swipeThreshold) {
          if (settingsPanel.classList.contains('open')) {
            settingsPanel.classList.remove('open');
          }
        }
      }
      
      // Detection type change
      document.getElementById('detection-type').addEventListener('change', (e) => {
        detectionType = e.target.value;
        
        switch (detectionType) {
          case 'motion':
            activeDetector = motionDetector;
            break;
          case 'color':
            activeDetector = colorTracker;
            break;
          case 'pose':
            activeDetector = poseDetector;
            break;
        }
      });
      
      // Sensitivity change
      document.getElementById('sensitivity').addEventListener('input', (e) => {
        sensitivity = parseInt(e.target.value);
        motionDetector.setSensitivity(sensitivity);
        colorTracker.setSensitivity(sensitivity);
      });
      
      // Min rep duration change
      document.getElementById('min-rep-duration').addEventListener('change', (e) => {
        minRepDuration = parseInt(e.target.value);
      });
      
      // Pause duration change (using the same value as minRepDuration for simplicity)
      document.getElementById('min-rep-duration').addEventListener('change', (e) => {
        // If we're currently in a pause, update the end time based on new duration
        if (inRepPause) {
          const remainingPercentage = (repPauseEndTime - Date.now()) / (minRepDuration);
          minRepDuration = parseInt(e.target.value);
          repPauseEndTime = Date.now() + (minRepDuration * remainingPercentage);
        } else {
          minRepDuration = parseInt(e.target.value);
        }
      });
      
      // Handle Safari audio unlock
      document.addEventListener('click', unlockAudio, { once: true });
      document.addEventListener('touchstart', unlockAudio, { once: true });
      
      // Navigation between pages
      document.querySelectorAll('.nav-item[data-page]').forEach(item => {
        item.addEventListener('click', () => {
          // Would implement page navigation in a full app
          document.querySelectorAll('.nav-item').forEach(navItem => {
            navItem.classList.remove('active');
          });
          item.classList.add('active');
        });
      });
    }
    
    // Unlock audio for Safari
    function unlockAudio() {
      repSound.play().then(() => {
        repSound.pause();
        repSound.currentTime = 0;
      }).catch(e => console.log('Audio unlock error:', e));
      
      milestoneSound.play().then(() => {
        milestoneSound.pause();
        milestoneSound.currentTime = 0;
      }).catch(e => console.log('Audio unlock error:', e));
    }
    
    // Local storage functions
    function saveToLocalStorage() {
      try {
        localStorage.setItem('repCounter_history', JSON.stringify(workoutHistory));
        localStorage.setItem('repCounter_totalReps', totalReps.toString());
      } catch (e) {
        console.error('Error saving to localStorage:', e);
      }
    }
    
    function loadFromLocalStorage() {
      try {
        const history = localStorage.getItem('repCounter_history');
        if (history) {
          workoutHistory = JSON.parse(history);
        }
        
        const savedTotalReps = localStorage.getItem('repCounter_totalReps');
        if (savedTotalReps) {
          totalReps = parseInt(savedTotalReps);
          todayReps.textContent = totalReps;
        }
      } catch (e) {
        console.error('Error loading from localStorage:', e);
      }
    }
    
    // Frame skipping for performance optimization
    let frameCount = 0;
    let inRepPause = false; // Flag to track if we're in the pause period after a rep
    let repPauseEndTime = 0; // When the pause period ends
    
    function optimizedDetectionLoop() {
      if (!video.paused && !video.ended) {
        // Process every 2nd frame for better performance
        frameCount++;
        if (frameCount % 2 === 0) {
          // Draw current frame
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          
          // Only run detection if workout is active
          if (workoutActive) {
            const now = Date.now();
            
            // Check if we're in a pause period after a rep
            if (inRepPause) {
              // If the pause period is over, exit the pause state
              if (now >= repPauseEndTime) {
                inRepPause = false;
                
                // Optional: Show visual indicator that next rep can be counted
                if (showDetection) {
                  ctx.fillStyle = 'rgba(46, 196, 182, 0.5)';
                  ctx.fillRect(canvas.width - 30, 10, 20, 20);
                  ctx.font = '16px Montserrat';
                  ctx.fillStyle = 'white';
                  ctx.fillText('Ready', canvas.width - 90, 25);
                }
              } else {
                // Still in pause period, show countdown
                if (showDetection) {
                  const remainingPause = Math.ceil((repPauseEndTime - now) / 1000);
                  ctx.fillStyle = 'rgba(255, 159, 28, 0.5)';
                  ctx.fillRect(canvas.width - 30, 10, 20, 20);
                  ctx.font = '16px Montserrat';
                  ctx.fillStyle = 'white';
                  ctx.fillText(`Pause: ${remainingPause}s`, canvas.width - 120, 25);
                }
              }
              
              // Still detect motion but don't count reps during pause
              activeDetector.detect(ctx, video);
            } else {
              // Not in pause period, detect motion and check for reps
              const repDetected = activeDetector.detect(ctx, video);
              
              if (repDetected && (now - lastRepTime) > minRepDuration) {
                // Increment rep counter
                reps++;
                totalReps++;
                lastRepTime = now;
                
                // Enter pause state
                inRepPause = true;
                repPauseEndTime = now + minRepDuration; // Use minRepDuration as pause duration
                
                // Update UI
                repCounter.textContent = `${reps} reps`;
                todayReps.textContent = totalReps;
                
                // Play sound
                if (document.getElementById('sound-effects').checked) {
                  repSound.play().catch(e => console.log('Audio play error:', e));
                }
                
                // Check for milestones
                if (reps % 10 === 0) {
                  if (document.getElementById('sound-effects').checked) {
                    milestoneSound.play().catch(e => console.log('Audio play error:', e));
                  }
                  
                  // Voice announcement
                  if (document.getElementById('voice-announcements').checked) {
                    announceReps(reps);
                  }
                }
                
                // Record rep timestamp
                repHistory.push({
                  timestamp: now,
                  workout: workoutStartTime
                });
                
                // Save to local storage
                if (document.getElementById('save-history').checked) {
                  saveToLocalStorage();
                }
              }
            }
          }
        } else {
          // Just draw the frame without detection
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        }
      }
      
      requestAnimationFrame(optimizedDetectionLoop);
    }
    
    // Initialize the application
    async function initApp() {
      // Show loader while initializing
      loader.style.display = 'flex';
      
      try {
        // Check if this is a mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        
        console.log('Initializing app for device:', { isMobile, isIOS });
        
        // Apply mobile-specific adjustments
        if (isMobile) {
          // Force landscape orientation for better experience
          if (window.screen && window.screen.orientation && window.screen.orientation.lock) {
            try {
              await window.screen.orientation.lock('landscape');
              console.log('Locked to landscape orientation');
            } catch (e) {
              console.log('Could not lock orientation:', e);
              // Show orientation guidance for mobile users
              const loaderMessage = document.querySelector('.loader-message');
              if (loaderMessage) {
                loaderMessage.textContent = 'For best experience, please use landscape orientation';
              }
            }
          }
          
          // iOS-specific adjustments
          if (isIOS) {
            // Add iOS viewport fix
            const viewportMeta = document.querySelector('meta[name="viewport"]');
            if (viewportMeta) {
              viewportMeta.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
            }
            
            // Add fullscreen guidance for iOS
            const iosGuidance = document.createElement('div');
            iosGuidance.className = 'ios-guidance';
            iosGuidance.innerHTML = 'For best experience, tap <b>Share</b> and <b>Add to Home Screen</b>, then open from there.';
            iosGuidance.style.cssText = 'position:fixed; top:0; left:0; right:0; background:rgba(231, 29, 54, 0.9); color:white; padding:10px; text-align:center; z-index:9999; font-size:14px;';
            document.body.appendChild(iosGuidance);
            
            // Auto-hide after 10 seconds
            setTimeout(() => {
              iosGuidance.style.display = 'none';
            }, 10000);
          }
        }
        
        // Setup camera
        await setupCamera();
        
        // Load settings
        loadFromLocalStorage();
        
        // Setup event listeners
        setupEventListeners();
        
        // Initialize charts
        initCharts();
        
        // Start detection loop
        optimizedDetectionLoop();
        
        // Add mobile menu toggle functionality
        setupMobileMenu();
        
        // Hide loader
        loader.style.display = 'none';
        
        // Add a tap event to ensure proper initialization on iOS
        if (isIOS) {
          const tapToStart = document.createElement('div');
          tapToStart.className = 'tap-to-start';
          tapToStart.innerHTML = 'Tap anywhere to start camera';
          tapToStart.style.cssText = 'position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:rgba(67, 97, 238, 0.9); color:white; padding:20px; border-radius:10px; text-align:center; z-index:9998; font-size:18px;';
          document.body.appendChild(tapToStart);
          
          const handleTap = () => {
            tapToStart.style.display = 'none';
            document.removeEventListener('click', handleTap);
            document.removeEventListener('touchend', handleTap);
          };
          
          document.addEventListener('click', handleTap);
          document.addEventListener('touchend', handleTap);
        }
      } catch (error) {
        console.error('Error initializing app:', error);
        const errorMessage = `Error initializing the application: ${error.message}. Please refresh and try again.`;
        alert(errorMessage);
        
        // Update loader to show error
        const loaderText = document.querySelector('.loader-text');
        if (loaderText) {
          loaderText.textContent = 'Initialization Failed';
          loaderText.style.color = 'var(--danger)';
        }
        
        const loaderMessage = document.querySelector('.loader-message');
        if (loaderMessage) {
          loaderMessage.innerHTML = `Error: ${error.message}<br>Please refresh the page or try a different browser.`;
          loaderMessage.style.color = 'var(--danger)';
        }
      }
    }
    
    // Setup mobile-specific menu functionality
    function setupMobileMenu() {
      const menuToggle = document.querySelector('.menu-toggle');
      const sidebar = document.querySelector('.sidebar');
      
      if (menuToggle && sidebar) {
        menuToggle.addEventListener('click', () => {
          sidebar.classList.toggle('open');
          menuToggle.classList.toggle('active');
        });
        
        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', (e) => {
          if (window.innerWidth <= 576 && 
              sidebar.classList.contains('open') && 
              !sidebar.contains(e.target) && 
              !menuToggle.contains(e.target)) {
            sidebar.classList.remove('open');
            menuToggle.classList.remove('active');
          }
        });
        
        // Add double-tap to close for mobile
        let lastTap = 0;
        document.addEventListener('touchend', (e) => {
          const currentTime = new Date().getTime();
          const tapLength = currentTime - lastTap;
          
          if (tapLength < 500 && tapLength > 0) {
            // Double tap detected
            if (window.innerWidth <= 576 && 
                sidebar.classList.contains('open') && 
                !sidebar.contains(e.target) && 
                !menuToggle.contains(e.target)) {
              sidebar.classList.remove('open');
              menuToggle.classList.remove('active');
            }
          }
          
          lastTap = currentTime;
        });
      }
    }

    // Load OpenCV.js with progress tracking and fallback mechanism
    function loadOpenCV() {
      return new Promise((resolve, reject) => {
        const progressBar = document.getElementById('loader-progress');
        const percentageText = document.getElementById('loader-percentage');
        const loaderText = document.querySelector('.loader-text');
        const loaderMessage = document.querySelector('.loader-message');
        
        // Define multiple CDN sources for fallback with more options
        const openCVSources = [
          // Try local file first if available (you'll need to download this file)
          window.location.origin + '/opencv.js',
          window.location.origin + '/lib/opencv.js',
          window.location.origin + '/js/opencv.js',
          // Then try CDN sources
          'https://docs.opencv.org/4.5.5/opencv.js', // Try older versions first as they might be more stable
          'https://docs.opencv.org/4.6.0/opencv.js',
          'https://docs.opencv.org/4.7.0/opencv.js',
          'https://docs.opencv.org/4.8.0/opencv.js',
          'https://docs.opencv.org/4.9.0/opencv.js',
          'https://cdn.jsdelivr.net/npm/opencv.js@1.2.1/opencv.min.js',
          'https://unpkg.com/opencv.js@1.2.1/opencv.js',
          'https://cdn.jsdelivr.net/npm/@techstark/opencv-js@4.7.0-release.1/opencv.js',
          'https://cdn.jsdelivr.net/npm/opencv-wasm@4.3.0-10/opencv.js',
          // Additional fallbacks
          'https://cdn.jsdelivr.net/npm/@techstark/opencv-js@4.5.5-release.2/opencv.js',
          'https://cdn.jsdelivr.net/npm/@techstark/opencv-js@4.5.4-release.2/opencv.js'
        ];
        
        // Log available sources for debugging
        console.log('OpenCV sources to try:', openCVSources);
        
        let currentSourceIndex = 0;
        let loadAttempts = 0;
        const maxAttempts = 2; // Try each source up to 2 times
        
        // Check if OpenCV is already loaded
        if (typeof cv !== 'undefined') {
          console.log('OpenCV.js already available');
          progressBar.style.width = '100%';
          percentageText.textContent = '100%';
          return resolve();
        }
        
        function tryLoadOpenCV() {
          if (currentSourceIndex >= openCVSources.length) {
            if (loadAttempts < maxAttempts) {
              loadAttempts++;
              currentSourceIndex = 0;
              console.log(`Retrying all sources (attempt ${loadAttempts} of ${maxAttempts})`);
              loaderMessage.textContent = `Retrying all sources (attempt ${loadAttempts} of ${maxAttempts})...`;
              setTimeout(tryLoadOpenCV, 1000); // Wait a second before retrying
              return;
            }
            
            // If all XHR attempts failed, try direct script loading as a last resort
            if (loadAttempts >= maxAttempts) {
              loaderMessage.textContent = 'Trying alternative loading method...';
              console.log('Trying direct script loading as last resort');
              
              // Try to load directly from a reliable CDN
              const script = document.createElement('script');
              script.src = 'https://docs.opencv.org/4.5.5/opencv.js'; // Use a stable version
              script.async = true;
              
              script.onload = function() {
                console.log('OpenCV.js loaded via direct script tag');
                progressBar.style.width = '100%';
                percentageText.textContent = '100%';
                loaderText.textContent = 'Initializing OpenCV.js...';
                
                // Check if cv object exists and wait for initialization
                if (typeof cv !== 'undefined') {
                  if (cv.onRuntimeInitialized) {
                    cv.onRuntimeInitialized = () => {
                      console.log('OpenCV.js initialized successfully via direct script');
                      resolve();
                    };
                  } else {
                    console.log('OpenCV.js already initialized via direct script');
                    resolve();
                  }
                } else {
                  // If cv doesn't exist yet, wait a bit and check again
                  let checkInterval = setInterval(() => {
                    if (typeof cv !== 'undefined') {
                      clearInterval(checkInterval);
                      console.log('OpenCV.js initialized after waiting (direct script)');
                      resolve();
                    }
                  }, 100);
                  
                  // Set a timeout to prevent infinite waiting
                  setTimeout(() => {
                    clearInterval(checkInterval);
                    if (typeof cv === 'undefined') {
                      loaderMessage.textContent = 'Failed to load OpenCV.js. Please check your internet connection and try again.';
                      loaderText.textContent = 'Loading Failed';
                      loaderText.style.color = 'var(--danger)';
                      
                      // Show retry button
                      const retryButton = document.getElementById('retry-loading');
                      if (retryButton) {
                        retryButton.style.display = 'block';
                        retryButton.onclick = () => {
                          // Reset UI
                          loaderText.textContent = 'Loading OpenCV.js...';
                          loaderText.style.color = 'var(--light)';
                          loaderMessage.textContent = 'Retrying download...';
                          retryButton.style.display = 'none';
                          
                          // Reset counters and try again
                          loadAttempts = 0;
                          currentSourceIndex = 0;
                          tryLoadOpenCV();
                        };
                      }
                      
                      // Don't reject the promise yet, allow retry
                      // reject(new Error('Failed to load OpenCV.js via direct script tag'));
                    }
                  }, 15000); // Wait 15 seconds max
                }
              };
              
              script.onerror = function() {
                loaderMessage.textContent = 'Failed to load OpenCV.js from all sources. Please check your internet connection and try again.';
                loaderText.textContent = 'Loading Failed';
                loaderText.style.color = 'var(--danger)';
                
                // Show retry button
                const retryButton = document.getElementById('retry-loading');
                if (retryButton) {
                  retryButton.style.display = 'block';
                  retryButton.onclick = () => {
                    // Reset UI
                    loaderText.textContent = 'Loading OpenCV.js...';
                    loaderText.style.color = 'var(--light)';
                    loaderMessage.textContent = 'Retrying download...';
                    retryButton.style.display = 'none';
                    
                    // Reset counters and try again
                    loadAttempts = 0;
                    currentSourceIndex = 0;
                    tryLoadOpenCV();
                  };
                }
                
                // Don't reject the promise yet, allow retry
                // reject(new Error('Failed to load OpenCV.js from all sources including direct script tag'));
              };
              
              document.head.appendChild(script);
              return;
            }
            
            loaderMessage.textContent = 'Failed to load OpenCV.js from all sources. Please check your internet connection and try again.';
            loaderText.textContent = 'Loading Failed';
            loaderText.style.color = 'var(--danger)';
            
            // Show retry button
            const retryButton = document.getElementById('retry-loading');
            if (retryButton) {
              retryButton.style.display = 'block';
              retryButton.onclick = () => {
                // Reset UI
                loaderText.textContent = 'Loading OpenCV.js...';
                loaderText.style.color = 'var(--light)';
                loaderMessage.textContent = 'Retrying download...';
                retryButton.style.display = 'none';
                
                // Reset counters and try again
                loadAttempts = 0;
                currentSourceIndex = 0;
                tryLoadOpenCV();
              };
            }
            
            // Don't reject the promise yet, allow retry
            // reject(new Error('Failed to load OpenCV.js from all sources'));
            return;
          }
          
          const currentSource = openCVSources[currentSourceIndex];
          loaderMessage.textContent = `Trying source ${currentSourceIndex + 1}/${openCVSources.length}`;
          console.log(`Attempting to load OpenCV.js from: ${currentSource}`);
          
          // Reset progress indicators
          progressBar.style.width = '0%';
          percentageText.textContent = '0%';
          
          // First, we need to fetch the file to track progress
          const xhr = new XMLHttpRequest();
          xhr.open('GET', currentSource, true);
          xhr.responseType = 'blob';
          
          // Set timeout for the request
          xhr.timeout = 30000; // 30 seconds timeout - increased for slower connections
          
          // Log the attempt
          console.log(`Fetching OpenCV.js from: ${currentSource} (attempt ${loadAttempts + 1}, source ${currentSourceIndex + 1}/${openCVSources.length})`);
          loaderMessage.textContent = `Downloading from source ${currentSourceIndex + 1}/${openCVSources.length}...`;
          
          // Track loading progress
          xhr.onprogress = (event) => {
            if (event.lengthComputable) {
              const percentComplete = Math.round((event.loaded / event.total) * 100);
              progressBar.style.width = percentComplete + '%';
              percentageText.textContent = percentComplete + '%';
            }
          };
          
          xhr.onload = function() {
            if (this.status === 200) {
              // Create a URL for the blob
              const blob = new Blob([this.response], {type: 'application/javascript'});
              const scriptURL = URL.createObjectURL(blob);
              
              // Now create and load the script
              const script = document.createElement('script');
              script.setAttribute('type', 'text/javascript');
              script.setAttribute('src', scriptURL);
              
              // Set a timeout for script loading
              const scriptLoadTimeout = setTimeout(() => {
                console.error(`Script load timeout for source ${currentSourceIndex + 1}`);
                URL.revokeObjectURL(scriptURL);
                currentSourceIndex++;
                tryLoadOpenCV(); // Try next source
              }, 20000); // 20 seconds timeout for script loading
              
              script.onload = () => {
                clearTimeout(scriptLoadTimeout);
                console.log('OpenCV.js script loaded');
                progressBar.style.width = '100%';
                percentageText.textContent = '100%';
                loaderText.textContent = 'Initializing OpenCV.js...';
                loaderMessage.textContent = 'Almost there! Setting up the workout environment...';
                
                // Check if cv object exists and wait for initialization
                if (typeof cv !== 'undefined') {
                  if (cv.onRuntimeInitialized) {
                    // If cv exists but not initialized yet
                    const originalOnRuntimeInitialized = cv.onRuntimeInitialized;
                    cv.onRuntimeInitialized = () => {
                      originalOnRuntimeInitialized?.();
                      console.log('OpenCV.js initialized successfully');
                      // Clean up the URL object
                      URL.revokeObjectURL(scriptURL);
                      resolve();
                    };
                  } else {
                    // If cv exists and is already initialized
                    console.log('OpenCV.js already initialized');
                    URL.revokeObjectURL(scriptURL);
                    resolve();
                  }
                } else {
                  // If cv doesn't exist yet, wait a bit and check again
                  let checkInterval = setInterval(() => {
                    if (typeof cv !== 'undefined') {
                      clearInterval(checkInterval);
                      
                      if (cv.onRuntimeInitialized) {
                        const originalOnRuntimeInitialized = cv.onRuntimeInitialized;
                        cv.onRuntimeInitialized = () => {
                          originalOnRuntimeInitialized?.();
                          console.log('OpenCV.js initialized after waiting');
                          URL.revokeObjectURL(scriptURL);
                          resolve();
                        };
                      } else {
                        console.log('OpenCV.js already initialized after waiting');
                        URL.revokeObjectURL(scriptURL);
                        resolve();
                      }
                    }
                  }, 100);
                  
                  // Set a timeout to prevent infinite waiting
                  setTimeout(() => {
                    clearInterval(checkInterval);
                    if (typeof cv === 'undefined') {
                      console.error(`OpenCV object not found after loading from source ${currentSourceIndex + 1}`);
                      URL.revokeObjectURL(scriptURL);
                      currentSourceIndex++;
                      tryLoadOpenCV(); // Try next source
                    }
                  }, 10000); // Wait 10 seconds max
                }
              };
              
              script.onerror = () => {
                clearTimeout(scriptLoadTimeout);
                console.error(`Failed to initialize OpenCV.js from source ${currentSourceIndex + 1}`);
                URL.revokeObjectURL(scriptURL);
                currentSourceIndex++;
                tryLoadOpenCV(); // Try next source
              };
              
              document.body.appendChild(script);
            } else {
              console.error(`Failed to load OpenCV.js from source ${currentSourceIndex + 1}: HTTP ${this.status}`);
              currentSourceIndex++;
              tryLoadOpenCV(); // Try next source
            }
          };
          
          xhr.onerror = (error) => {
            console.error(`Network error loading OpenCV.js from source ${currentSourceIndex + 1}:`, error);
            loaderMessage.textContent = `Network error with source ${currentSourceIndex + 1}. Trying next source...`;
            currentSourceIndex++;
            setTimeout(() => tryLoadOpenCV(), 1000); // Add a small delay before trying next source
          };
          
          xhr.ontimeout = () => {
            console.error(`Timeout loading OpenCV.js from source ${currentSourceIndex + 1}`);
            loaderMessage.textContent = `Timeout with source ${currentSourceIndex + 1}. Trying next source...`;
            currentSourceIndex++;
            setTimeout(() => tryLoadOpenCV(), 1000); // Add a small delay before trying next source
          };
          
          xhr.send();
        }
        
        // Start the loading process
        tryLoadOpenCV();
      });
    }

    // Check browser compatibility with enhanced mobile support
    function checkBrowserCompatibility() {
      const isCompatible = {
        status: true,
        issues: [],
        warnings: []
      };
      
      // Detect device type and browser
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
      const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      const isFirefox = navigator.userAgent.indexOf('Firefox') !== -1;
      const isChrome = /Chrome/.test(navigator.userAgent) && !/Edge|Edg/.test(navigator.userAgent);
      const isEdge = /Edge|Edg/.test(navigator.userAgent);
      
      // More detailed WebAssembly support check (required for OpenCV.js)
      let webAssemblySupported = typeof WebAssembly !== 'undefined';
      
      if (!webAssemblySupported) {
        isCompatible.status = false;
        isCompatible.issues.push('WebAssembly is not supported in this browser. OpenCV.js requires WebAssembly support. Please use a modern browser like Chrome, Firefox, or Edge.');
      } else {
        // Check for more advanced WebAssembly features needed by OpenCV.js
        try {
          // Test if we can instantiate a simple module
          const module = new WebAssembly.Module(new Uint8Array([
            0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00
          ]));
          const instance = new WebAssembly.Instance(module);
          
          // If we get here, basic WebAssembly is working
          console.log('WebAssembly basic support confirmed');
        } catch (e) {
          console.error('WebAssembly instantiation failed:', e);
          isCompatible.warnings.push('Your browser has limited WebAssembly support. OpenCV.js may not work correctly.');
        }
      }
      
      // Check for MediaDevices API (for camera access)
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        isCompatible.status = false;
        isCompatible.issues.push('Camera access is not supported in this browser. Please use a modern browser like Chrome, Firefox, or Edge.');
      }
      
      // Check for Canvas API
      if (!document.createElement('canvas').getContext) {
        isCompatible.status = false;
        isCompatible.issues.push('Canvas API is not supported in this browser.');
      }
      
      // Check for localStorage (for saving workout history)
      try {
        localStorage.setItem('test', 'test');
        localStorage.removeItem('test');
      } catch (e) {
        // Make this a warning instead of a critical issue
        isCompatible.warnings.push('LocalStorage is not available. Workout history will not be saved.');
      }
      
      // Mobile-specific checks
      if (isMobile) {
        // Add mobile-specific warnings
        isCompatible.warnings.push('For best experience, use your device in landscape orientation.');
        
        // iOS Safari specific warnings
        if (isIOS) {
          if (isSafari) {
            isCompatible.warnings.push('On iOS Safari, you may need to enable camera access in Settings > Safari > Camera & Microphone Access.');
            
            // Check for iOS version - older versions have WebAssembly limitations
            const iosVersion = (navigator.userAgent).match(/OS (\d+)_(\d+)_?(\d+)?/);
            if (iosVersion && parseInt(iosVersion[1], 10) < 14) {
              isCompatible.warnings.push('Your iOS version may have limited WebAssembly support. Consider updating your device for better performance.');
            }
          }
          
          // Check for iOS PWA mode which has better camera access
          const isInPWA = window.navigator.standalone === true;
          if (!isInPWA) {
            isCompatible.warnings.push('For better performance, add this app to your home screen.');
          }
        }
        
        // Android Chrome specific guidance
        if (/Android/i.test(navigator.userAgent)) {
          if (/Chrome/i.test(navigator.userAgent)) {
            isCompatible.warnings.push('On Android Chrome, you may need to grant camera permissions when prompted.');
            
            // Check for Chrome version
            const chromeVersion = navigator.userAgent.match(/Chrome\/(\d+)/);
            if (chromeVersion && parseInt(chromeVersion[1], 10) < 90) {
              isCompatible.warnings.push('Your Chrome version is older. Consider updating for better performance.');
            }
          } else {
            isCompatible.warnings.push('For best experience on Android, use Chrome browser.');
          }
        }
        
        // Check for device memory API and warn if low memory
        if (navigator.deviceMemory) {
          if (navigator.deviceMemory < 4) {
            isCompatible.warnings.push('Your device has limited memory (less than 4GB). Performance may be affected.');
          }
          if (navigator.deviceMemory < 2) {
            isCompatible.warnings.push('Your device has very limited memory (less than 2GB). The app may crash or run slowly.');
          }
        } else {
          // If deviceMemory API is not available, make a general warning
          isCompatible.warnings.push('Unable to detect device memory. If you experience performance issues, try closing other apps.');
        }
      }
      
      // Display warnings if there are any but the app is still compatible
      if (isCompatible.warnings.length > 0 && isCompatible.status) {
        // Create a warning element that will be shown after the app loads
        window.addEventListener('DOMContentLoaded', () => {
          setTimeout(() => {
            const warningElement = document.createElement('div');
            warningElement.className = 'mobile-compatibility-warning';
            warningElement.innerHTML = `
              <div class="warning-content">
                <h3>⚠️ Tips for Better Experience</h3>
                <ul>${isCompatible.warnings.map(w => `<li>${w}</li>`).join('')}</ul>
                <button class="btn btn-sm btn-outline close-warning">Got it</button>
              </div>
            `;
            document.body.appendChild(warningElement);
            
            // Style the warning
            const style = document.createElement('style');
            style.textContent = `
              .mobile-compatibility-warning {
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(26, 26, 46, 0.95);
                border: 1px solid var(--primary);
                border-radius: 12px;
                padding: 15px;
                z-index: 9999;
                max-width: 90%;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
                animation: slideUp 0.5s ease-out;
              }
              .warning-content h3 {
                font-size: 1rem;
                margin-bottom: 10px;
                color: var(--warning);
              }
              .warning-content ul {
                padding-left: 20px;
                margin-bottom: 15px;
                font-size: 0.85rem;
              }
              .close-warning {
                padding: 5px 10px;
                font-size: 0.8rem;
              }
              @keyframes slideUp {
                from { transform: translate(-50%, 100%); opacity: 0; }
                to { transform: translate(-50%, 0); opacity: 1; }
              }
            `;
            document.head.appendChild(style);
            
            // Add close button functionality
            warningElement.querySelector('.close-warning').addEventListener('click', () => {
              warningElement.style.animation = 'slideDown 0.5s ease-out forwards';
              setTimeout(() => warningElement.remove(), 500);
            });
            
            // Auto-hide after 15 seconds
            setTimeout(() => {
              if (document.body.contains(warningElement)) {
                warningElement.style.animation = 'slideDown 0.5s ease-out forwards';
                setTimeout(() => warningElement.remove(), 500);
              }
            }, 15000);
          }, 3000); // Show warnings 3 seconds after app loads
        });
      }
      
      return isCompatible;
    }
    
    // Main initialization
    window.onload = async () => {
      try {
        // Check browser compatibility first
        const compatibility = checkBrowserCompatibility();
        if (!compatibility.status) {
          throw new Error('Browser compatibility issues: ' + compatibility.issues.join(' '));
        }
        
        // Display any compatibility warnings
        if (compatibility.warnings.length > 0) {
          const warningContainer = document.getElementById('warning-container');
          const warningList = document.getElementById('warning-list');
          
          if (warningContainer && warningList) {
            warningList.innerHTML = compatibility.warnings.map(warning => `<li>${warning}</li>`).join('');
            warningContainer.style.display = 'block';
            
            // Auto-hide warnings after 10 seconds
            setTimeout(() => {
              warningContainer.style.opacity = '0';
              setTimeout(() => {
                warningContainer.style.display = 'none';
                warningContainer.style.opacity = '1';
              }, 500);
            }, 10000);
          }
        }
        
        // Load OpenCV.js with specific error handling
        try {
          await loadOpenCV();
          console.log('OpenCV loaded successfully');
        } catch (opencvError) {
          console.error('OpenCV loading failed:', opencvError);
          throw new Error(`Failed to load OpenCV: ${opencvError.message}`);
        }
        
        // Initialize the application
        await initApp();
      } catch (error) {
        console.error('Initialization error:', error);
        
        // Check if the error is related to OpenCV
        const isOpenCVError = error.message.includes('OpenCV') || error.message.includes('cv');
        
        // Create an error message element
        const errorElement = document.createElement('div');
        errorElement.style.cssText = 'position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:rgba(231, 29, 54, 0.9); color:white; padding:20px; border-radius:10px; text-align:center; z-index:9999; max-width:80%; box-shadow:0 5px 15px rgba(0,0,0,0.3);';
        
        // Provide more specific error messages based on the error type
        if (isOpenCVError) {
          errorElement.innerHTML = `
            <h3 style="margin-bottom:15px;">Failed to load OpenCV.js library</h3>
            <p>This could be due to:</p>
            <ul style="text-align:left; margin:10px 0;">
              <li>Network connectivity issues</li>
              <li>Content blockers or ad blockers</li>
              <li>Browser security settings</li>
              <li>Insufficient memory on your device</li>
            </ul>
            <p>Please try:</p>
            <ul style="text-align:left; margin:10px 0;">
              <li>Refreshing the page</li>
              <li>Using a different browser (Chrome or Firefox recommended)</li>
              <li>Disabling content blockers or ad blockers</li>
              <li>Clearing your browser cache</li>
              <li>Closing other tabs and applications</li>
            </ul>
            <button id="retry-button" style="background:var(--primary); border:none; color:white; padding:10px 20px; border-radius:5px; margin-top:15px; cursor:pointer;">Retry Installation</button>
          `;
        } else {
          errorElement.innerHTML = `
            <h3 style="margin-bottom:15px;">Application Error</h3>
            <p>${error.message}</p>
            <p style="margin-top:10px;">Please try refreshing the page or check your internet connection.</p>
            <p>If the problem persists, try using a different browser.</p>
            <button id="retry-button" style="background:var(--primary); border:none; color:white; padding:10px 20px; border-radius:5px; margin-top:15px; cursor:pointer;">Retry</button>
          `;
        }
        
        document.body.appendChild(errorElement);
        
        // Add retry button functionality
        document.getElementById('retry-button').onclick = () => window.location.reload();
        
        // Log detailed error for debugging
        console.log('Detailed error information:', {
          errorMessage: error.message,
          errorStack: error.stack,
          browserInfo: navigator.userAgent,
          timestamp: new Date().toISOString()
        });
      }
    };
  </script>
</body>
</html>
