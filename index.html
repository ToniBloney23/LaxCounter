<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Wall Ball Rep Tracker</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
  <script src="https://docs.opencv.org/4.9.0/opencv.js"></script>

  <style>
    body {
      background: linear-gradient(to right, #232526, #414345);
      color: #f0f0f0;
      font-family: 'Poppins', sans-serif;
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      text-align: center;
    }
    h1 {
      margin-bottom: 0.5rem;
      font-size: 2.8rem;
      color: #4CAF50;
    }
    p {
      margin-bottom: 2rem;
      font-size: 1.1rem;
      color: #ccc;
    }
    #reps-container {
      font-size: 3rem;
      margin-bottom: 1.5rem;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1.5rem;
      background: #2c2c2c;
      padding: 1rem 2rem;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    canvas {
      max-width: 100%;
      width: 100%;
      height: auto;
      border-radius: 10px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      display: block;
      margin: 1rem auto;
    }
    #loader {
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      z-index: 9999;
      background: #232526;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 2rem;
      color: #4CAF50;
    }
    .control-button {
      font-size: 1.2rem;
      padding: 1rem 2rem;
      border: none;
      border-radius: 25px;
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      background-image: linear-gradient(to right, #2196F3, #1976D2);
    }
    .control-button:hover {
        transform: translateY(-3px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
    }
    .button-container {
        margin-bottom: 1rem;
    }
    #reset-button {
        background-image: linear-gradient(to right, #D32F2F, #C62828);
    }
    .slider-container {
        margin: 1rem auto;
        width: 80%;
        max-width: 400px;
    }
  </style>
</head>
<body>
  <div id="loader">Loading OpenCV.js...</div>
  <div class="container">
    <h1>Wall Ball Rep Tracker</h1>
    <p>Use your camera to count your wall ball reps automatically.</p>
    <div id="reps-container">
      <div id="reps">Reps: 0</div>
      <div id="timer-container">Time: 0s</div>
    </div>
    <div class="button-container">
        <button id="save-button" class="control-button">Save</button>
        <button id="reset-button" class="control-button">Reset</button>
    </div>
    <canvas id="canvas"></canvas>
    <video id="video" autoplay playsinline muted style="display: none;"></video>
    <div class="slider-container">
        <label for="sensitivity-slider">Sensitivity</label>
        <input type="range" id="sensitivity-slider" min="500" max="5000" value="2000">
        <span id="sensitivity-value">2000</span>
    </div>
  </div>

  <audio id="rep-sound" src="https://actions.google.com/sounds/v1/sports/tennis_ball_hit_bounce.ogg" preload="auto"></audio>

  <script>
    (function() {
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const repsDisplay = document.getElementById('reps');
        const repSound = document.getElementById('rep-sound');
        const loader = document.getElementById('loader');
        const resetButton = document.getElementById('reset-button');
        const sensitivitySlider = document.getElementById('sensitivity-slider');
        const sensitivityValue = document.getElementById('sensitivity-value');
        const timerContainer = document.getElementById('timer-container');

        let reps = 0;
        let timerInterval;
        let seconds = 0;
        let lastRepTime = 0;
        const repCooldown = 300; // 300ms cooldown between reps
        let tracker;

        class ArmSleeveTracker {
            constructor() {
                this.sleeveState = 'down'; // down, up
                this.lastSleeveCenterY = null;
                this.minContourArea = parseInt(sensitivitySlider.value, 10);
            }

            detect(context, videoElement) {
                let src = new cv.Mat(videoElement.height, videoElement.width, cv.CV_8UC4);
                let hsv = new cv.Mat();
                let mask = new cv.Mat();
                let contours = new cv.MatVector();
                let hierarchy = new cv.Mat();

                try {
                    context.drawImage(videoElement, 0, 0, videoElement.width, videoElement.height);
                    src.data.set(context.getImageData(0, 0, videoElement.width, videoElement.height).data);

                    cv.cvtColor(src, hsv, cv.COLOR_RGBA2RGB);
                    cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);

                    let lowerWhite = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [0, 0, 180, 0]);
                    let upperWhite = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [180, 40, 255, 255]);
                    cv.inRange(hsv, lowerWhite, upperWhite, mask);
                    lowerWhite.delete();
                    upperWhite.delete();

                    cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                    let largestContour = null;
                    let maxArea = 0;
                    for (let i = 0; i < contours.size(); ++i) {
                        let cnt = contours.get(i);
                        let area = cv.contourArea(cnt, false);
                        if (area > maxArea) {
                            if (largestContour) largestContour.delete();
                            maxArea = area;
                            largestContour = cnt;
                        } else {
                            cnt.delete();
                        }
                    }

                    const currentTime = Date.now();

                    if (largestContour && maxArea > this.minContourArea) {
                        const M = cv.moments(largestContour);
                        if (M.m00 !== 0) {
                            const sleeveCenterY = M.m01 / M.m00;

                            if (this.lastSleeveCenterY !== null) {
                                if (sleeveCenterY < this.lastSleeveCenterY - 5 && this.sleeveState === 'down') {
                                    this.sleeveState = 'up';
                                } else if (sleeveCenterY > this.lastSleeveCenterY + 5 && this.sleeveState === 'up') {
                                    if (currentTime - lastRepTime > repCooldown) {
                                        reps++;
                                        repsDisplay.textContent = `Reps: ${reps}`;
                                        repSound.play().catch(e => console.error("Audio play failed", e));
                                        lastRepTime = currentTime;
                                    }
                                    this.sleeveState = 'down';
                                }
                            }
                            this.lastSleeveCenterY = sleeveCenterY;
                        }
                        largestContour.delete();
                    } else {
                        this.lastSleeveCenterY = null;
                    }

                } catch (err) {
                    console.error("Error in detection loop:", err);
                } finally {
                    src.delete();
                    hsv.delete();
                    mask.delete();
                    contours.delete();
                    hierarchy.delete();
                }
            }
        }

        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal: 640 }, height: { ideal: 480 } } });
                video.srcObject = stream;
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        video.width = video.videoWidth;
                        video.height = video.videoHeight;
                        canvas.width = video.width;
                        canvas.height = video.height;
                        resolve(video);
                    };
                });
            } catch (err) {
                console.error("Camera setup failed:", err);
                loader.innerHTML = 'Camera access denied or not available. Please check permissions and refresh.';
            }
        }

        function gameLoop() {
            if (!video.paused && !video.ended && tracker) {
                tracker.detect(ctx, video);
            }
            requestAnimationFrame(gameLoop);
        }

        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                seconds++;
                let minutes = Math.floor(seconds / 60);
                let remainingSeconds = seconds % 60;
                timerContainer.textContent = `Time: ${minutes}m ${remainingSeconds}s`;
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        function resetTimer() {
            stopTimer();
            seconds = 0;
            timerContainer.textContent = 'Time: 0s';
        }

        function setupEventListeners() {
            sensitivitySlider.addEventListener('input', (e) => {
                if(tracker) tracker.minContourArea = parseInt(e.target.value, 10);
                sensitivityValue.textContent = e.target.value;
            });

            resetButton.addEventListener('click', () => {
                reps = 0;
                repsDisplay.textContent = 'Reps: 0';
                if(tracker) tracker.sleeveState = 'down';
                resetTimer();
                startTimer();
            });
        }

        async function main() {
            await setupCamera();
            tracker = new ArmSleeveTracker();
            setupEventListeners();
            loader.style.display = 'none';
            gameLoop();
            startTimer();
        }

        // Wait for OpenCV to be ready
        if (typeof cv !== 'undefined') {
            cv.onRuntimeInitialized = main;
        } else {
            loader.innerHTML = 'Failed to load OpenCV.js. Please refresh.';
        }
    })();
  </script>
</body>
</html>
