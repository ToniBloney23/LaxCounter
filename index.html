<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Brick Wall Ball Counter</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --safe-area-top: env(safe-area-inset-top, 0px);
            --safe-area-bottom: env(safe-area-inset-bottom, 0px);
        }
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        body {
            font-family: 'Roboto Mono', monospace;
            color: #e0e0e0;
        }
        #video-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1;
        }
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        #ui-container {
            position: relative;
            z-index: 1;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            padding-top: var(--safe-area-top);
            padding-bottom: var(--safe-area-bottom);
        }

        #counter-container {
            background: rgba(20, 20, 20, 0.7);
            backdrop-filter: blur(10px);
            padding: 10px 25px;
            border-radius: 50px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            margin-top: var(--safe-area-top);
        }

        #counter-container h1 {
            margin: 0;
            font-size: 1.2em;
            color: #e67e22; /* Brick color */
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #counter {
            font-size: 3em;
            font-weight: 700;
            color: #fff;
            margin: 0;
        }

        #controls {
            background: rgba(20, 20, 20, 0.7);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            max-width: 90%;
            margin-bottom: var(--safe-area-bottom);
        }

        #startButton {
            background: linear-gradient(to right, #d35400, #e67e22);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            font-family: 'Roboto Mono', monospace;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #startButton:disabled {
            background: #555;
            cursor: not-allowed;
        }

        #startButton:not(:disabled):hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(230, 126, 34, 0.4);
        }

        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 8px solid #f3f3f3;
            border-top: 8px solid #e67e22;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            z-index: 10;
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        #instructions p {
            margin: 5px 0;
        }

        /* Responsive Design for Mobile */
        @media (max-width: 768px) {
            #counter-container h1 {
                font-size: 1em;
            }
            #counter {
                font-size: 2.5em;
            }
            #startButton {
                padding: 12px 24px;
                font-size: 1em;
            }
            #instructions p {
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <video id="video-background" autoplay muted playsinline></video>
    <canvas id="canvas"></canvas>

    <div id="ui-container">
        <div id="loader"></div>
        <div id="counter-container">
            <h1>Hits</h1>
            <p id="counter">0</p>
        </div>
        <div id="controls">
            <div id="instructions"></div>
            <button id="startButton" disabled>Loading Model...</button>
                <button id="testButton">Test Hit</button>
        </div>
    </div>

    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
    <!-- COCO-SSD model -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>

    <script>
        const video = document.getElementById('video-background');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const counterElement = document.getElementById('counter');
        const loader = document.getElementById('loader');
        const controls = document.getElementById('controls');
        const instructions = document.getElementById('instructions');
        const testButton = document.getElementById('testButton');

        let model = null;
        let repCount = 0;
        let lastWallHitTime = 0;
        let isDetecting = false;

        // --- Main Setup ---
        async function setup() {
            loader.style.display = 'block';
            instructions.innerHTML = '<p><strong>Loading Model...</strong></p><p>Please wait a moment.</p>';
            await cocoSsd.load().then(loadedModel => {
                model = loadedModel;
                console.log('Object detection model loaded.');
                loader.style.display = 'none';
                startButton.disabled = false;
                startButton.textContent = 'Start Camera';
                instructions.innerHTML = '<p><strong>Brick Wall Counter</strong></p><p>Press Start and aim the camera. A hit is counted when the ball enters the wall zone (right side).</p>';
            });

            startButton.addEventListener('click', async () => {
                if (!isDetecting) {
                    await setupCamera();
                    isDetecting = true;
                    detectFrame();
                    controls.style.display = 'none';
                }
            });

            testButton.addEventListener('click', () => {
                checkForHit(canvas.width); // Simulate a hit at the far right edge
            });
        }

        // Initial state
        startButton.disabled = true;

        async function setupCamera() {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { 
                    facingMode: 'environment',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                },
                audio: false
            });
            video.srcObject = stream;
            return new Promise((resolve) => {
                video.onloadedmetadata = () => {
                    // Match canvas internal resolution to video's
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    video.play();
                    resolve(video);
                };
            });
        }

        async function detectFrame() {
            if (!model || !isDetecting) {
                return;
            }

            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            const predictions = await model.detect(canvas);



            // Define the wall zone
            const wallZoneStart = canvas.width * 0.8;
            ctx.strokeStyle = 'rgba(230, 126, 34, 0.7)';
            ctx.lineWidth = 4;
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.moveTo(wallZoneStart, 0);
            ctx.lineTo(wallZoneStart, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);

            const ball = predictions.find(p => p.class === 'sports ball');

            if (ball) {
                // Draw bounding box
                ctx.strokeStyle = '#2ecc71';
                ctx.lineWidth = 2;
                ctx.strokeRect(ball.bbox[0], ball.bbox[1], ball.bbox[2], ball.bbox[3]);
                ctx.fillStyle = '#2ecc71';
                ctx.fillText(`${ball.class} (${Math.round(ball.score * 100)}%)`, ball.bbox[0], ball.bbox[1] > 10 ? ball.bbox[1] - 5 : 10);

                const ballCenterX = ball.bbox[0] + ball.bbox[2] / 2;
                checkForHit(ballCenterX);
            } 

            requestAnimationFrame(detectFrame);
        }

        function checkForHit(ballX) {
            const now = Date.now();
            const wallZoneStart = canvas.width * 0.8;
            const cooldown = 1500; // 1.5 seconds

            if (ballX > wallZoneStart && now - lastWallHitTime > cooldown) {
                repCount++;
                counterElement.textContent = repCount;
                lastWallHitTime = now;
                console.log(`Hit counted! Total: ${repCount}`);
                // Visual feedback for hit
                document.getElementById('counter-container').style.transform = 'scale(1.2)';
                setTimeout(() => {
                    document.getElementById('counter-container').style.transform = 'scale(1)';
                }, 200);
            }
        }

        setup();
    </script>
</body>
</html>
